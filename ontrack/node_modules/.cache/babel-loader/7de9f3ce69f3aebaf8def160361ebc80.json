{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nvar messages_1 = require(\"./messages\");\n\nvar buffer_reader_1 = require(\"./buffer-reader\");\n\nvar assert_1 = __importDefault(require(\"assert\")); // every message is prefixed with a single bye\n\n\nvar CODE_LENGTH = 1; // every message has an int32 length which includes itself but does\n// NOT include the code in the length\n\nvar LEN_LENGTH = 4;\nvar HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nvar emptyBuffer = Buffer.allocUnsafe(0);\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(opts) {\n    _classCallCheck(this, Parser);\n\n    this.buffer = emptyBuffer;\n    this.bufferLength = 0;\n    this.bufferOffset = 0;\n    this.reader = new buffer_reader_1.BufferReader();\n\n    if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {\n      throw new Error('Binary mode not supported yet');\n    }\n\n    this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(buffer, callback) {\n      this.mergeBuffer(buffer);\n      var bufferFullLength = this.bufferOffset + this.bufferLength;\n      var offset = this.bufferOffset;\n\n      while (offset + HEADER_LENGTH <= bufferFullLength) {\n        // code is 1 byte long - it identifies the message type\n        var code = this.buffer[offset]; // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n\n        var length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\n        var fullMessageLength = CODE_LENGTH + length;\n\n        if (fullMessageLength + offset <= bufferFullLength) {\n          var message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\n          callback(message);\n          offset += fullMessageLength;\n        } else {\n          break;\n        }\n      }\n\n      if (offset === bufferFullLength) {\n        // No more use for the buffer\n        this.buffer = emptyBuffer;\n        this.bufferLength = 0;\n        this.bufferOffset = 0;\n      } else {\n        // Adjust the cursors of remainingBuffer\n        this.bufferLength = bufferFullLength - offset;\n        this.bufferOffset = offset;\n      }\n    }\n  }, {\n    key: \"mergeBuffer\",\n    value: function mergeBuffer(buffer) {\n      if (this.bufferLength > 0) {\n        var newLength = this.bufferLength + buffer.byteLength;\n        var newFullLength = newLength + this.bufferOffset;\n\n        if (newFullLength > this.buffer.byteLength) {\n          // We can't concat the new buffer with the remaining one\n          var newBuffer;\n\n          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n            // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n            newBuffer = this.buffer;\n          } else {\n            // Allocate a new larger buffer\n            var newBufferLength = this.buffer.byteLength * 2;\n\n            while (newLength >= newBufferLength) {\n              newBufferLength *= 2;\n            }\n\n            newBuffer = Buffer.allocUnsafe(newBufferLength);\n          } // Move the remaining buffer to the new one\n\n\n          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\n          this.buffer = newBuffer;\n          this.bufferOffset = 0;\n        } // Concat the new buffer with the remaining one\n\n\n        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\n        this.bufferLength = newLength;\n      } else {\n        this.buffer = buffer;\n        this.bufferOffset = 0;\n        this.bufferLength = buffer.byteLength;\n      }\n    }\n  }, {\n    key: \"handlePacket\",\n    value: function handlePacket(offset, code, length, bytes) {\n      switch (code) {\n        case 50\n        /* BindComplete */\n        :\n          return messages_1.bindComplete;\n\n        case 49\n        /* ParseComplete */\n        :\n          return messages_1.parseComplete;\n\n        case 51\n        /* CloseComplete */\n        :\n          return messages_1.closeComplete;\n\n        case 110\n        /* NoData */\n        :\n          return messages_1.noData;\n\n        case 115\n        /* PortalSuspended */\n        :\n          return messages_1.portalSuspended;\n\n        case 99\n        /* CopyDone */\n        :\n          return messages_1.copyDone;\n\n        case 87\n        /* ReplicationStart */\n        :\n          return messages_1.replicationStart;\n\n        case 73\n        /* EmptyQuery */\n        :\n          return messages_1.emptyQuery;\n\n        case 68\n        /* DataRow */\n        :\n          return this.parseDataRowMessage(offset, length, bytes);\n\n        case 67\n        /* CommandComplete */\n        :\n          return this.parseCommandCompleteMessage(offset, length, bytes);\n\n        case 90\n        /* ReadyForQuery */\n        :\n          return this.parseReadyForQueryMessage(offset, length, bytes);\n\n        case 65\n        /* NotificationResponse */\n        :\n          return this.parseNotificationMessage(offset, length, bytes);\n\n        case 82\n        /* AuthenticationResponse */\n        :\n          return this.parseAuthenticationResponse(offset, length, bytes);\n\n        case 83\n        /* ParameterStatus */\n        :\n          return this.parseParameterStatusMessage(offset, length, bytes);\n\n        case 75\n        /* BackendKeyData */\n        :\n          return this.parseBackendKeyData(offset, length, bytes);\n\n        case 69\n        /* ErrorMessage */\n        :\n          return this.parseErrorMessage(offset, length, bytes, 'error');\n\n        case 78\n        /* NoticeMessage */\n        :\n          return this.parseErrorMessage(offset, length, bytes, 'notice');\n\n        case 84\n        /* RowDescriptionMessage */\n        :\n          return this.parseRowDescriptionMessage(offset, length, bytes);\n\n        case 116\n        /* ParameterDescriptionMessage */\n        :\n          return this.parseParameterDescriptionMessage(offset, length, bytes);\n\n        case 71\n        /* CopyIn */\n        :\n          return this.parseCopyInMessage(offset, length, bytes);\n\n        case 72\n        /* CopyOut */\n        :\n          return this.parseCopyOutMessage(offset, length, bytes);\n\n        case 100\n        /* CopyData */\n        :\n          return this.parseCopyData(offset, length, bytes);\n\n        default:\n          assert_1.default.fail(\"unknown message code: \".concat(code.toString(16)));\n      }\n    }\n  }, {\n    key: \"parseReadyForQueryMessage\",\n    value: function parseReadyForQueryMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var status = this.reader.string(1);\n      return new messages_1.ReadyForQueryMessage(length, status);\n    }\n  }, {\n    key: \"parseCommandCompleteMessage\",\n    value: function parseCommandCompleteMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var text = this.reader.cstring();\n      return new messages_1.CommandCompleteMessage(length, text);\n    }\n  }, {\n    key: \"parseCopyData\",\n    value: function parseCopyData(offset, length, bytes) {\n      var chunk = bytes.slice(offset, offset + (length - 4));\n      return new messages_1.CopyDataMessage(length, chunk);\n    }\n  }, {\n    key: \"parseCopyInMessage\",\n    value: function parseCopyInMessage(offset, length, bytes) {\n      return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\n    }\n  }, {\n    key: \"parseCopyOutMessage\",\n    value: function parseCopyOutMessage(offset, length, bytes) {\n      return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\n    }\n  }, {\n    key: \"parseCopyMessage\",\n    value: function parseCopyMessage(offset, length, bytes, messageName) {\n      this.reader.setBuffer(offset, bytes);\n      var isBinary = this.reader.byte() !== 0;\n      var columnCount = this.reader.int16();\n      var message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n\n      for (var i = 0; i < columnCount; i++) {\n        message.columnTypes[i] = this.reader.int16();\n      }\n\n      return message;\n    }\n  }, {\n    key: \"parseNotificationMessage\",\n    value: function parseNotificationMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var processId = this.reader.int32();\n      var channel = this.reader.cstring();\n      var payload = this.reader.cstring();\n      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n    }\n  }, {\n    key: \"parseRowDescriptionMessage\",\n    value: function parseRowDescriptionMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var fieldCount = this.reader.int16();\n      var message = new messages_1.RowDescriptionMessage(length, fieldCount);\n\n      for (var i = 0; i < fieldCount; i++) {\n        message.fields[i] = this.parseField();\n      }\n\n      return message;\n    }\n  }, {\n    key: \"parseField\",\n    value: function parseField() {\n      var name = this.reader.cstring();\n      var tableID = this.reader.int32();\n      var columnID = this.reader.int16();\n      var dataTypeID = this.reader.int32();\n      var dataTypeSize = this.reader.int16();\n      var dataTypeModifier = this.reader.int32();\n      var mode = this.reader.int16() === 0 ? 'text' : 'binary';\n      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n    }\n  }, {\n    key: \"parseParameterDescriptionMessage\",\n    value: function parseParameterDescriptionMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var parameterCount = this.reader.int16();\n      var message = new messages_1.ParameterDescriptionMessage(length, parameterCount);\n\n      for (var i = 0; i < parameterCount; i++) {\n        message.dataTypeIDs[i] = this.reader.int32();\n      }\n\n      return message;\n    }\n  }, {\n    key: \"parseDataRowMessage\",\n    value: function parseDataRowMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var fieldCount = this.reader.int16();\n      var fields = new Array(fieldCount);\n\n      for (var i = 0; i < fieldCount; i++) {\n        var len = this.reader.int32(); // a -1 for length means the value of the field is null\n\n        fields[i] = len === -1 ? null : this.reader.string(len);\n      }\n\n      return new messages_1.DataRowMessage(length, fields);\n    }\n  }, {\n    key: \"parseParameterStatusMessage\",\n    value: function parseParameterStatusMessage(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var name = this.reader.cstring();\n      var value = this.reader.cstring();\n      return new messages_1.ParameterStatusMessage(length, name, value);\n    }\n  }, {\n    key: \"parseBackendKeyData\",\n    value: function parseBackendKeyData(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var processID = this.reader.int32();\n      var secretKey = this.reader.int32();\n      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n    }\n  }, {\n    key: \"parseAuthenticationResponse\",\n    value: function parseAuthenticationResponse(offset, length, bytes) {\n      this.reader.setBuffer(offset, bytes);\n      var code = this.reader.int32(); // TODO(bmc): maybe better types here\n\n      var message = {\n        name: 'authenticationOk',\n        length: length\n      };\n\n      switch (code) {\n        case 0:\n          // AuthenticationOk\n          break;\n\n        case 3:\n          // AuthenticationCleartextPassword\n          if (message.length === 8) {\n            message.name = 'authenticationCleartextPassword';\n          }\n\n          break;\n\n        case 5:\n          // AuthenticationMD5Password\n          if (message.length === 12) {\n            message.name = 'authenticationMD5Password';\n            var salt = this.reader.bytes(4);\n            return new messages_1.AuthenticationMD5Password(length, salt);\n          }\n\n          break;\n\n        case 10:\n          // AuthenticationSASL\n          message.name = 'authenticationSASL';\n          message.mechanisms = [];\n          var mechanism;\n\n          do {\n            mechanism = this.reader.cstring();\n\n            if (mechanism) {\n              message.mechanisms.push(mechanism);\n            }\n          } while (mechanism);\n\n          break;\n\n        case 11:\n          // AuthenticationSASLContinue\n          message.name = 'authenticationSASLContinue';\n          message.data = this.reader.string(length - 8);\n          break;\n\n        case 12:\n          // AuthenticationSASLFinal\n          message.name = 'authenticationSASLFinal';\n          message.data = this.reader.string(length - 8);\n          break;\n\n        default:\n          throw new Error('Unknown authenticationOk message type ' + code);\n      }\n\n      return message;\n    }\n  }, {\n    key: \"parseErrorMessage\",\n    value: function parseErrorMessage(offset, length, bytes, name) {\n      this.reader.setBuffer(offset, bytes);\n      var fields = {};\n      var fieldType = this.reader.string(1);\n\n      while (fieldType !== '\\0') {\n        fields[fieldType] = this.reader.cstring();\n        fieldType = this.reader.string(1);\n      }\n\n      var messageValue = fields.M;\n      var message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n      message.severity = fields.S;\n      message.code = fields.C;\n      message.detail = fields.D;\n      message.hint = fields.H;\n      message.position = fields.P;\n      message.internalPosition = fields.p;\n      message.internalQuery = fields.q;\n      message.where = fields.W;\n      message.schema = fields.s;\n      message.table = fields.t;\n      message.column = fields.c;\n      message.dataType = fields.d;\n      message.constraint = fields.n;\n      message.file = fields.F;\n      message.line = fields.L;\n      message.routine = fields.R;\n      return message;\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports.Parser = Parser;","map":null,"metadata":{},"sourceType":"script"}