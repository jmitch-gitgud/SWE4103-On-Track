{"ast":null,"code":"import { isIP } from 'node:net';\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */\n\n/**\n * @module utils/referrer\n * @private\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */\n\nexport function stripURLForUseAsAReferrer(url) {\n  let originOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  // 1. If url is null, return no referrer.\n  if (url == null) {\n    // eslint-disable-line no-eq-null, eqeqeq\n    return 'no-referrer';\n  }\n\n  url = new URL(url); // 2. If url's scheme is a local scheme, then return no referrer.\n\n  if (/^(about|blob|data):$/.test(url.protocol)) {\n    return 'no-referrer';\n  } // 3. Set url's username to the empty string.\n\n\n  url.username = ''; // 4. Set url's password to null.\n  // Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n\n  url.password = ''; // 5. Set url's fragment to null.\n  // Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n\n  url.hash = ''; // 6. If the origin-only flag is true, then:\n\n  if (originOnly) {\n    // 6.1. Set url's path to null.\n    // Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n    url.pathname = ''; // 6.2. Set url's query to null.\n    // Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n\n    url.search = '';\n  } // 7. Return url.\n\n\n  return url;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */\n\nexport const ReferrerPolicy = new Set(['', 'no-referrer', 'no-referrer-when-downgrade', 'same-origin', 'origin', 'strict-origin', 'origin-when-cross-origin', 'strict-origin-when-cross-origin', 'unsafe-url']);\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */\n\nexport const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */\n\nexport function validateReferrerPolicy(referrerPolicy) {\n  if (!ReferrerPolicy.has(referrerPolicy)) {\n    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n  }\n\n  return referrerPolicy;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\n\nexport function isOriginPotentiallyTrustworthy(url) {\n  // 1. If origin is an opaque origin, return \"Not Trustworthy\".\n  // Not applicable\n  // 2. Assert: origin is a tuple origin.\n  // Not for implementations\n  // 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n  if (/^(http|ws)s:$/.test(url.protocol)) {\n    return true;\n  } // 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n\n\n  const hostIp = url.host.replace(/(^\\[)|(]$)/g, '');\n  const hostIPVersion = isIP(hostIp);\n\n  if (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n    return true;\n  }\n\n  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n    return true;\n  } // 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n  // We are returning FALSE here because we cannot ensure conformance to\n  // let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n\n\n  if (url.host === 'localhost' || url.host.endsWith('.localhost')) {\n    return false;\n  } // 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n\n\n  if (url.protocol === 'file:') {\n    return true;\n  } // 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n  // Not supported\n  // 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n  // Not supported\n  // 9. Return \"Not Trustworthy\".\n\n\n  return false;\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\n\nexport function isUrlPotentiallyTrustworthy(url) {\n  // 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n  if (/^about:(blank|srcdoc)$/.test(url)) {\n    return true;\n  } // 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n\n\n  if (url.protocol === 'data:') {\n    return true;\n  } // Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n  // created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n  // trustworthy.\n\n\n  if (/^(blob|filesystem):$/.test(url.protocol)) {\n    return true;\n  } // 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.\n\n\n  return isOriginPotentiallyTrustworthy(url);\n}\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */\n\n/**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */\n\nexport function determineRequestsReferrer(request) {\n  let {\n    referrerURLCallback,\n    referrerOriginCallback\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n  // these cases:\n  // > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n  // > Note: If request's referrer policy is the empty string, Fetch will not call into this\n  // > algorithm.\n  if (request.referrer === 'no-referrer' || request.referrerPolicy === '') {\n    return null;\n  } // 1. Let policy be request's associated referrer policy.\n\n\n  const policy = request.referrerPolicy; // 2. Let environment be request's client.\n  // not applicable to node.js\n  // 3. Switch on request's referrer:\n\n  if (request.referrer === 'about:client') {\n    return 'no-referrer';\n  } // \"a URL\": Let referrerSource be request's referrer.\n\n\n  const referrerSource = request.referrer; // 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n\n  let referrerURL = stripURLForUseAsAReferrer(referrerSource); // 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n  //    origin-only flag set to true.\n\n  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true); // 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n  //    referrerURL to referrerOrigin.\n\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin;\n  } // 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n  //    policy considerations in the interests of minimizing data leakage. For example, the user\n  //    agent could strip the URL down to an origin, modify its host, replace it with an empty\n  //    string, etc.\n\n\n  if (referrerURLCallback) {\n    referrerURL = referrerURLCallback(referrerURL);\n  }\n\n  if (referrerOriginCallback) {\n    referrerOrigin = referrerOriginCallback(referrerOrigin);\n  } // 8.Execute the statements corresponding to the value of policy:\n\n\n  const currentURL = new URL(request.url);\n\n  switch (policy) {\n    case 'no-referrer':\n      return 'no-referrer';\n\n    case 'origin':\n      return referrerOrigin;\n\n    case 'unsafe-url':\n      return referrerURL;\n\n    case 'strict-origin':\n      // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n      //    potentially trustworthy URL, then return no referrer.\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer';\n      } // 2. Return referrerOrigin.\n\n\n      return referrerOrigin.toString();\n\n    case 'strict-origin-when-cross-origin':\n      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n      //    return referrerURL.\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      } // 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n      //    potentially trustworthy URL, then return no referrer.\n\n\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer';\n      } // 3. Return referrerOrigin.\n\n\n      return referrerOrigin;\n\n    case 'same-origin':\n      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n      //    return referrerURL.\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      } // 2. Return no referrer.\n\n\n      return 'no-referrer';\n\n    case 'origin-when-cross-origin':\n      // 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n      //    return referrerURL.\n      if (referrerURL.origin === currentURL.origin) {\n        return referrerURL;\n      } // Return referrerOrigin.\n\n\n      return referrerOrigin;\n\n    case 'no-referrer-when-downgrade':\n      // 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n      //    potentially trustworthy URL, then return no referrer.\n      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer';\n      } // 2. Return referrerURL.\n\n\n      return referrerURL;\n\n    default:\n      throw new TypeError(`Invalid referrerPolicy: ${policy}`);\n  }\n}\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */\n\nexport function parseReferrerPolicyFromHeader(headers) {\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n  //    and response’s header list.\n  const policyTokens = (headers.get('referrer-policy') || '').split(/[,\\s]+/); // 2. Let policy be the empty string.\n\n  let policy = ''; // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n  //    string, then set policy to token.\n  // Note: This algorithm loops over multiple policy values to allow deployment of new policy\n  // values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.\n\n  for (const token of policyTokens) {\n    if (token && ReferrerPolicy.has(token)) {\n      policy = token;\n    }\n  } // 4. Return policy.\n\n\n  return policy;\n}","map":{"version":3,"names":["isIP","stripURLForUseAsAReferrer","url","originOnly","URL","test","protocol","username","password","hash","pathname","search","ReferrerPolicy","Set","DEFAULT_REFERRER_POLICY","validateReferrerPolicy","referrerPolicy","has","TypeError","isOriginPotentiallyTrustworthy","hostIp","host","replace","hostIPVersion","endsWith","isUrlPotentiallyTrustworthy","determineRequestsReferrer","request","referrerURLCallback","referrerOriginCallback","referrer","policy","referrerSource","referrerURL","referrerOrigin","toString","length","currentURL","origin","parseReferrerPolicyFromHeader","headers","policyTokens","get","split","token"],"sources":["/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/node-fetch/src/utils/referrer.js"],"sourcesContent":["import {isIP} from 'node:net';\n\n/**\n * @external URL\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}\n */\n\n/**\n * @module utils/referrer\n * @private\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy §8.4. Strip url for use as a referrer}\n * @param {string} URL\n * @param {boolean} [originOnly=false]\n */\nexport function stripURLForUseAsAReferrer(url, originOnly = false) {\n\t// 1. If url is null, return no referrer.\n\tif (url == null) { // eslint-disable-line no-eq-null, eqeqeq\n\t\treturn 'no-referrer';\n\t}\n\n\turl = new URL(url);\n\n\t// 2. If url's scheme is a local scheme, then return no referrer.\n\tif (/^(about|blob|data):$/.test(url.protocol)) {\n\t\treturn 'no-referrer';\n\t}\n\n\t// 3. Set url's username to the empty string.\n\turl.username = '';\n\n\t// 4. Set url's password to null.\n\t// Note: `null` appears to be a mistake as this actually results in the password being `\"null\"`.\n\turl.password = '';\n\n\t// 5. Set url's fragment to null.\n\t// Note: `null` appears to be a mistake as this actually results in the fragment being `\"#null\"`.\n\turl.hash = '';\n\n\t// 6. If the origin-only flag is true, then:\n\tif (originOnly) {\n\t\t// 6.1. Set url's path to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the path being `\"/null\"`.\n\t\turl.pathname = '';\n\n\t\t// 6.2. Set url's query to null.\n\t\t// Note: `null` appears to be a mistake as this actually results in the query being `\"?null\"`.\n\t\turl.search = '';\n\t}\n\n\t// 7. Return url.\n\treturn url;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}\n */\nexport const ReferrerPolicy = new Set([\n\t'',\n\t'no-referrer',\n\t'no-referrer-when-downgrade',\n\t'same-origin',\n\t'origin',\n\t'strict-origin',\n\t'origin-when-cross-origin',\n\t'strict-origin-when-cross-origin',\n\t'unsafe-url'\n]);\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}\n */\nexport const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy §3. Referrer Policies}\n * @param {string} referrerPolicy\n * @returns {string} referrerPolicy\n */\nexport function validateReferrerPolicy(referrerPolicy) {\n\tif (!ReferrerPolicy.has(referrerPolicy)) {\n\t\tthrow new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);\n\t}\n\n\treturn referrerPolicy;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy §3.2. Is origin potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isOriginPotentiallyTrustworthy(url) {\n\t// 1. If origin is an opaque origin, return \"Not Trustworthy\".\n\t// Not applicable\n\n\t// 2. Assert: origin is a tuple origin.\n\t// Not for implementations\n\n\t// 3. If origin's scheme is either \"https\" or \"wss\", return \"Potentially Trustworthy\".\n\tif (/^(http|ws)s:$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return \"Potentially Trustworthy\".\n\tconst hostIp = url.host.replace(/(^\\[)|(]$)/g, '');\n\tconst hostIPVersion = isIP(hostIp);\n\n\tif (hostIPVersion === 4 && /^127\\./.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\tif (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {\n\t\treturn true;\n\t}\n\n\t// 5. If origin's host component is \"localhost\" or falls within \".localhost\", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return \"Potentially Trustworthy\".\n\t// We are returning FALSE here because we cannot ensure conformance to\n\t// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)\n\tif (url.host === 'localhost' || url.host.endsWith('.localhost')) {\n\t\treturn false;\n\t}\n\n\t// 6. If origin's scheme component is file, return \"Potentially Trustworthy\".\n\tif (url.protocol === 'file:') {\n\t\treturn true;\n\t}\n\n\t// 7. If origin's scheme component is one which the user agent considers to be authenticated, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 8. If origin has been configured as a trustworthy origin, return \"Potentially Trustworthy\".\n\t// Not supported\n\n\t// 9. Return \"Not Trustworthy\".\n\treturn false;\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy §3.3. Is url potentially trustworthy?}\n * @param {external:URL} url\n * @returns `true`: \"Potentially Trustworthy\", `false`: \"Not Trustworthy\"\n */\nexport function isUrlPotentiallyTrustworthy(url) {\n\t// 1. If url is \"about:blank\" or \"about:srcdoc\", return \"Potentially Trustworthy\".\n\tif (/^about:(blank|srcdoc)$/.test(url)) {\n\t\treturn true;\n\t}\n\n\t// 2. If url's scheme is \"data\", return \"Potentially Trustworthy\".\n\tif (url.protocol === 'data:') {\n\t\treturn true;\n\t}\n\n\t// Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were\n\t// created. Therefore, blobs created in a trustworthy origin will themselves be potentially\n\t// trustworthy.\n\tif (/^(blob|filesystem):$/.test(url.protocol)) {\n\t\treturn true;\n\t}\n\n\t// 3. Return the result of executing §3.2 Is origin potentially trustworthy? on url's origin.\n\treturn isOriginPotentiallyTrustworthy(url);\n}\n\n/**\n * Modifies the referrerURL to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerURLCallback\n * @param {external:URL} referrerURL\n * @returns {external:URL} modified referrerURL\n */\n\n/**\n * Modifies the referrerOrigin to enforce any extra security policy considerations.\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}, step 7\n * @callback module:utils/referrer~referrerOriginCallback\n * @param {external:URL} referrerOrigin\n * @returns {external:URL} modified referrerOrigin\n */\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy §8.3. Determine request's Referrer}\n * @param {Request} request\n * @param {object} o\n * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback\n * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback\n * @returns {external:URL} Request's referrer\n */\nexport function determineRequestsReferrer(request, {referrerURLCallback, referrerOriginCallback} = {}) {\n\t// There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for\n\t// these cases:\n\t// > Note: If request's referrer is \"no-referrer\", Fetch will not call into this algorithm.\n\t// > Note: If request's referrer policy is the empty string, Fetch will not call into this\n\t// > algorithm.\n\tif (request.referrer === 'no-referrer' || request.referrerPolicy === '') {\n\t\treturn null;\n\t}\n\n\t// 1. Let policy be request's associated referrer policy.\n\tconst policy = request.referrerPolicy;\n\n\t// 2. Let environment be request's client.\n\t// not applicable to node.js\n\n\t// 3. Switch on request's referrer:\n\tif (request.referrer === 'about:client') {\n\t\treturn 'no-referrer';\n\t}\n\n\t// \"a URL\": Let referrerSource be request's referrer.\n\tconst referrerSource = request.referrer;\n\n\t// 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.\n\tlet referrerURL = stripURLForUseAsAReferrer(referrerSource);\n\n\t// 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the\n\t//    origin-only flag set to true.\n\tlet referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);\n\n\t// 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set\n\t//    referrerURL to referrerOrigin.\n\tif (referrerURL.toString().length > 4096) {\n\t\treferrerURL = referrerOrigin;\n\t}\n\n\t// 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary\n\t//    policy considerations in the interests of minimizing data leakage. For example, the user\n\t//    agent could strip the URL down to an origin, modify its host, replace it with an empty\n\t//    string, etc.\n\tif (referrerURLCallback) {\n\t\treferrerURL = referrerURLCallback(referrerURL);\n\t}\n\n\tif (referrerOriginCallback) {\n\t\treferrerOrigin = referrerOriginCallback(referrerOrigin);\n\t}\n\n\t// 8.Execute the statements corresponding to the value of policy:\n\tconst currentURL = new URL(request.url);\n\n\tswitch (policy) {\n\t\tcase 'no-referrer':\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin':\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'unsafe-url':\n\t\t\treturn referrerURL;\n\n\t\tcase 'strict-origin':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerOrigin.\n\t\t\treturn referrerOrigin.toString();\n\n\t\tcase 'strict-origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 3. Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'same-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// 2. Return no referrer.\n\t\t\treturn 'no-referrer';\n\n\t\tcase 'origin-when-cross-origin':\n\t\t\t// 1. If the origin of referrerURL and the origin of request's current URL are the same, then\n\t\t\t//    return referrerURL.\n\t\t\tif (referrerURL.origin === currentURL.origin) {\n\t\t\t\treturn referrerURL;\n\t\t\t}\n\n\t\t\t// Return referrerOrigin.\n\t\t\treturn referrerOrigin;\n\n\t\tcase 'no-referrer-when-downgrade':\n\t\t\t// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a\n\t\t\t//    potentially trustworthy URL, then return no referrer.\n\t\t\tif (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {\n\t\t\t\treturn 'no-referrer';\n\t\t\t}\n\n\t\t\t// 2. Return referrerURL.\n\t\t\treturn referrerURL;\n\n\t\tdefault:\n\t\t\tthrow new TypeError(`Invalid referrerPolicy: ${policy}`);\n\t}\n}\n\n/**\n * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy §8.1. Parse a referrer policy from a Referrer-Policy header}\n * @param {Headers} headers Response headers\n * @returns {string} policy\n */\nexport function parseReferrerPolicyFromHeader(headers) {\n\t// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`\n\t//    and response’s header list.\n\tconst policyTokens = (headers.get('referrer-policy') || '').split(/[,\\s]+/);\n\n\t// 2. Let policy be the empty string.\n\tlet policy = '';\n\n\t// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty\n\t//    string, then set policy to token.\n\t// Note: This algorithm loops over multiple policy values to allow deployment of new policy\n\t// values with fallbacks for older user agents, as described in § 11.1 Unknown Policy Values.\n\tfor (const token of policyTokens) {\n\t\tif (token && ReferrerPolicy.has(token)) {\n\t\t\tpolicy = token;\n\t\t}\n\t}\n\n\t// 4. Return policy.\n\treturn policy;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}