{"ast":null,"code":"// Copyright 2012 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n'use strict';\n\nvar MemoryStore = require('./memory').MemoryStore;\n\nvar utils = require('./lookup');\n\nvar Lookup = utils.Lookup;\n\nvar util = require('util');\n\nvar Heap = require('binaryheap');\n\nvar MemoryStoreExpire = function MemoryStoreExpire(store, zone, opts) {\n  opts = opts || {};\n  this._store = store;\n  this._zone = zone;\n  this._max_keys = opts.max_keys;\n  this._ttl = new Heap(true);\n};\n\nMemoryStoreExpire.prototype.get = function (domain, key, cb) {\n  var self = this;\n\n  this._store.get(domain, key, function (err, results) {\n    var i, j, type, record;\n    var nresults = {};\n    var now = Date.now();\n\n    for (i in results) {\n      type = results[i];\n\n      for (j in type) {\n        record = type[j];\n        record.ttl = Math.round((record._ttl_expires - now) / 1000);\n\n        if (record.ttl > 0) {\n          if (!nresults[i]) {\n            nresults[i] = [];\n          }\n\n          nresults[i].push(record);\n        } else {\n          self._ttl.remove(record);\n\n          self._store.delete(self._zone, record.name, record.type, function () {});\n        }\n      }\n    }\n\n    cb(err, nresults);\n  });\n};\n\nMemoryStoreExpire.prototype.set = function (domain, key, data, cb) {\n  var i, j, type, record, expires;\n  var self = this;\n  var now = Date.now();\n  key = utils.ensure_absolute(key);\n\n  for (i in data) {\n    type = data[i];\n\n    for (j in type) {\n      record = type[j];\n      expires = record.ttl * 1000 + now;\n      record._ttl_expires = expires;\n\n      self._ttl.insert(record, expires);\n    }\n  }\n\n  while (this._ttl.length > this._max_keys) {\n    var record = this._ttl.pop();\n\n    this._store.delete(this._zone, record.name, record.type);\n  }\n\n  this._store.set(domain, key, data, function (err, results) {\n    if (cb) cb(err, results);\n  });\n};\n\nMemoryStoreExpire.prototype.delete = function (domain, key, type, cb) {\n  if (!cb) {\n    cb = type;\n    type = undefined;\n  }\n\n  var self = this;\n\n  this._store.get(domain, utils.ensure_absolute(key), function (gerr, gresults) {\n    var i, j, ktype, record;\n\n    for (i in gresults) {\n      ktype = gresults[i];\n\n      for (j in ktype) {\n        record = ktype[j];\n\n        self._ttl.remove(record);\n      }\n    }\n\n    if (!gresults) {\n      if (cb) cb(gerr, gresults);\n      return;\n    }\n\n    self._store.delete(domain, key, type, function (err, results) {\n      if (cb) cb(err, results);\n    });\n  });\n};\n\nvar Cache = module.exports = function (opts) {\n  opts = opts || {};\n  this._zone = '.' || opts.zone;\n  this._store = undefined;\n\n  this.purge = function () {\n    this._store = new MemoryStoreExpire(opts.store || new MemoryStore(), this._zone, opts);\n  };\n\n  this.purge();\n};\n\nCache.prototype.store = function (packet) {\n  var self = this;\n  var c = {};\n\n  function each(record) {\n    var r = c[record.name.toLowerCase()];\n    var t;\n    if (!r) r = c[record.name.toLowerCase()] = {};\n    t = r[record.type];\n    if (!t) t = r[record.type] = [];\n    t.push(record);\n  }\n\n  packet.answer.forEach(each);\n  packet.authority.forEach(each);\n  packet.additional.forEach(each);\n  Object.keys(c).forEach(function (key) {\n    self._store.set(self._zone, utils.ensure_absolute(key), c[key]);\n  });\n};\n\nCache.prototype.lookup = function (question, cb) {\n  var self = this;\n  Lookup(this._store, this._zone, question, function (err, results) {\n    var i,\n        record,\n        found = false;\n\n    for (i in results) {\n      record = results[i];\n\n      if (record.type == question.type) {\n        found = true;\n        break;\n      }\n    }\n\n    if (results && !found) {\n      self._store.delete(self._zone, utils.ensure_absolute(question.name));\n\n      results.forEach(function (rr) {\n        self._store.delete(self._zone, utils.ensure_absolute(rr.name));\n      });\n      results = null;\n    }\n\n    cb(results);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}