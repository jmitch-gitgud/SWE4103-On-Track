{"ast":null,"code":"'use strict';\n\nvar _createClass = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar NOOP = function NOOP() {};\n\nvar removeWhere = function removeWhere(list, predicate) {\n  var i = list.findIndex(predicate);\n  return i === -1 ? undefined : list.splice(i, 1)[0];\n};\n\nvar IdleItem = function IdleItem(client, idleListener, timeoutId) {\n  _classCallCheck(this, IdleItem);\n\n  this.client = client;\n  this.idleListener = idleListener;\n  this.timeoutId = timeoutId;\n};\n\nvar PendingItem = function PendingItem(callback) {\n  _classCallCheck(this, PendingItem);\n\n  this.callback = callback;\n};\n\nfunction throwOnDoubleRelease() {\n  throw new Error('Release called on client which has already been released to the pool.');\n}\n\nfunction promisify(Promise, callback) {\n  if (callback) {\n    return {\n      callback: callback,\n      result: undefined\n    };\n  }\n\n  var rej;\n  var res;\n\n  var cb = function cb(err, client) {\n    err ? rej(err) : res(client);\n  };\n\n  var result = new Promise(function (resolve, reject) {\n    res = resolve;\n    rej = reject;\n  });\n  return {\n    callback: cb,\n    result: result\n  };\n}\n\nfunction makeIdleListener(pool, client) {\n  return function idleListener(err) {\n    err.client = client;\n    client.removeListener('error', idleListener);\n    client.on('error', function () {\n      pool.log('additional client error after disconnection due to error', err);\n    });\n\n    pool._remove(client); // TODO - document that once the pool emits an error\n    // the client has already been closed & purged and is unusable\n\n\n    pool.emit('error', err, client);\n  };\n}\n\nvar Pool = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Pool, _EventEmitter);\n\n  function Pool(options, Client) {\n    var _this;\n\n    _classCallCheck(this, Pool);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pool).call(this));\n    _this.options = Object.assign({}, options);\n\n    if (options != null && 'password' in options) {\n      // \"hiding\" the password so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(_this.options, 'password', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: options.password\n      });\n    }\n\n    if (options != null && options.ssl && options.ssl.key) {\n      // \"hiding\" the ssl->key so it doesn't show up in stack traces\n      // or if the client is console.logged\n      Object.defineProperty(_this.options.ssl, 'key', {\n        enumerable: false\n      });\n    }\n\n    _this.options.max = _this.options.max || _this.options.poolSize || 10;\n    _this.options.maxUses = _this.options.maxUses || Infinity;\n    _this.options.allowExitOnIdle = _this.options.allowExitOnIdle || false;\n    _this.options.maxLifetimeSeconds = _this.options.maxLifetimeSeconds || 0;\n\n    _this.log = _this.options.log || function () {};\n\n    _this.Client = _this.options.Client || Client || require('pg').Client;\n    _this.Promise = _this.options.Promise || global.Promise;\n\n    if (typeof _this.options.idleTimeoutMillis === 'undefined') {\n      _this.options.idleTimeoutMillis = 10000;\n    }\n\n    _this._clients = [];\n    _this._idle = [];\n    _this._expired = new WeakSet();\n    _this._pendingQueue = [];\n    _this._endCallback = undefined;\n    _this.ending = false;\n    _this.ended = false;\n    return _this;\n  }\n\n  _createClass(Pool, [{\n    key: \"_isFull\",\n    value: function _isFull() {\n      return this._clients.length >= this.options.max;\n    }\n  }, {\n    key: \"_pulseQueue\",\n    value: function _pulseQueue() {\n      var _this2 = this;\n\n      this.log('pulse queue');\n\n      if (this.ended) {\n        this.log('pulse queue ended');\n        return;\n      }\n\n      if (this.ending) {\n        this.log('pulse queue on ending');\n\n        if (this._idle.length) {\n          this._idle.slice().map(function (item) {\n            _this2._remove(item.client);\n          });\n        }\n\n        if (!this._clients.length) {\n          this.ended = true;\n\n          this._endCallback();\n        }\n\n        return;\n      } // if we don't have any waiting, do nothing\n\n\n      if (!this._pendingQueue.length) {\n        this.log('no queued requests');\n        return;\n      } // if we don't have any idle clients and we have no more room do nothing\n\n\n      if (!this._idle.length && this._isFull()) {\n        return;\n      }\n\n      var pendingItem = this._pendingQueue.shift();\n\n      if (this._idle.length) {\n        var idleItem = this._idle.pop();\n\n        clearTimeout(idleItem.timeoutId);\n        var client = idleItem.client;\n        client.ref && client.ref();\n        var idleListener = idleItem.idleListener;\n        return this._acquireClient(client, pendingItem, idleListener, false);\n      }\n\n      if (!this._isFull()) {\n        return this.newClient(pendingItem);\n      }\n\n      throw new Error('unexpected condition');\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove(client) {\n      var removed = removeWhere(this._idle, function (item) {\n        return item.client === client;\n      });\n\n      if (removed !== undefined) {\n        clearTimeout(removed.timeoutId);\n      }\n\n      this._clients = this._clients.filter(function (c) {\n        return c !== client;\n      });\n      client.end();\n      this.emit('remove', client);\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(cb) {\n      var _this3 = this;\n\n      if (this.ending) {\n        var err = new Error('Cannot use a pool after calling end on the pool');\n        return cb ? cb(err) : this.Promise.reject(err);\n      }\n\n      var response = promisify(this.Promise, cb);\n      var result = response.result; // if we don't have to connect a new client, don't do so\n\n      if (this._isFull() || this._idle.length) {\n        // if we have idle clients schedule a pulse immediately\n        if (this._idle.length) {\n          process.nextTick(function () {\n            return _this3._pulseQueue();\n          });\n        }\n\n        if (!this.options.connectionTimeoutMillis) {\n          this._pendingQueue.push(new PendingItem(response.callback));\n\n          return result;\n        }\n\n        var queueCallback = function queueCallback(err, res, done) {\n          clearTimeout(tid);\n          response.callback(err, res, done);\n        };\n\n        var pendingItem = new PendingItem(queueCallback); // set connection timeout on checking out an existing client\n\n        var tid = setTimeout(function () {\n          // remove the callback from pending waiters because\n          // we're going to call it with a timeout error\n          removeWhere(_this3._pendingQueue, function (i) {\n            return i.callback === queueCallback;\n          });\n          pendingItem.timedOut = true;\n          response.callback(new Error('timeout exceeded when trying to connect'));\n        }, this.options.connectionTimeoutMillis);\n\n        this._pendingQueue.push(pendingItem);\n\n        return result;\n      }\n\n      this.newClient(new PendingItem(response.callback));\n      return result;\n    }\n  }, {\n    key: \"newClient\",\n    value: function newClient(pendingItem) {\n      var _this4 = this;\n\n      var client = new this.Client(this.options);\n\n      this._clients.push(client);\n\n      var idleListener = makeIdleListener(this, client);\n      this.log('checking client timeout'); // connection timeout logic\n\n      var tid;\n      var timeoutHit = false;\n\n      if (this.options.connectionTimeoutMillis) {\n        tid = setTimeout(function () {\n          _this4.log('ending client due to timeout');\n\n          timeoutHit = true; // force kill the node driver, and let libpq do its teardown\n\n          client.connection ? client.connection.stream.destroy() : client.end();\n        }, this.options.connectionTimeoutMillis);\n      }\n\n      this.log('connecting new client');\n      client.connect(function (err) {\n        if (tid) {\n          clearTimeout(tid);\n        }\n\n        client.on('error', idleListener);\n\n        if (err) {\n          _this4.log('client failed to connect', err); // remove the dead client from our list of clients\n\n\n          _this4._clients = _this4._clients.filter(function (c) {\n            return c !== client;\n          });\n\n          if (timeoutHit) {\n            err.message = 'Connection terminated due to connection timeout';\n          } // this client wonâ€™t be released, so move on immediately\n\n\n          _this4._pulseQueue();\n\n          if (!pendingItem.timedOut) {\n            pendingItem.callback(err, undefined, NOOP);\n          }\n        } else {\n          _this4.log('new client connected');\n\n          if (_this4.options.maxLifetimeSeconds !== 0) {\n            var maxLifetimeTimeout = setTimeout(function () {\n              _this4.log('ending client due to expired lifetime');\n\n              _this4._expired.add(client);\n\n              var idleIndex = _this4._idle.findIndex(function (idleItem) {\n                return idleItem.client === client;\n              });\n\n              if (idleIndex !== -1) {\n                _this4._acquireClient(client, new PendingItem(function (err, client, clientRelease) {\n                  return clientRelease();\n                }), idleListener, false);\n              }\n            }, _this4.options.maxLifetimeSeconds * 1000);\n            maxLifetimeTimeout.unref();\n            client.once('end', function () {\n              return clearTimeout(maxLifetimeTimeout);\n            });\n          }\n\n          return _this4._acquireClient(client, pendingItem, idleListener, true);\n        }\n      });\n    } // acquire a client for a pending work item\n\n  }, {\n    key: \"_acquireClient\",\n    value: function _acquireClient(client, pendingItem, idleListener, isNew) {\n      if (isNew) {\n        this.emit('connect', client);\n      }\n\n      this.emit('acquire', client);\n      client.release = this._releaseOnce(client, idleListener);\n      client.removeListener('error', idleListener);\n\n      if (!pendingItem.timedOut) {\n        if (isNew && this.options.verify) {\n          this.options.verify(client, function (err) {\n            if (err) {\n              client.release(err);\n              return pendingItem.callback(err, undefined, NOOP);\n            }\n\n            pendingItem.callback(undefined, client, client.release);\n          });\n        } else {\n          pendingItem.callback(undefined, client, client.release);\n        }\n      } else {\n        if (isNew && this.options.verify) {\n          this.options.verify(client, client.release);\n        } else {\n          client.release();\n        }\n      }\n    } // returns a function that wraps _release and throws if called more than once\n\n  }, {\n    key: \"_releaseOnce\",\n    value: function _releaseOnce(client, idleListener) {\n      var _this5 = this;\n\n      var released = false;\n      return function (err) {\n        if (released) {\n          throwOnDoubleRelease();\n        }\n\n        released = true;\n\n        _this5._release(client, idleListener, err);\n      };\n    } // release a client back to the poll, include an error\n    // to remove it from the pool\n\n  }, {\n    key: \"_release\",\n    value: function _release(client, idleListener, err) {\n      var _this6 = this;\n\n      client.on('error', idleListener);\n      client._poolUseCount = (client._poolUseCount || 0) + 1; // TODO(bmc): expose a proper, public interface _queryable and _ending\n\n      if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n        if (client._poolUseCount >= this.options.maxUses) {\n          this.log('remove expended client');\n        }\n\n        this._remove(client);\n\n        this._pulseQueue();\n\n        return;\n      }\n\n      var isExpired = this._expired.has(client);\n\n      if (isExpired) {\n        this.log('remove expired client');\n\n        this._expired.delete(client);\n\n        this._remove(client);\n\n        this._pulseQueue();\n\n        return;\n      } // idle timeout\n\n\n      var tid;\n\n      if (this.options.idleTimeoutMillis) {\n        tid = setTimeout(function () {\n          _this6.log('remove idle client');\n\n          _this6._remove(client);\n        }, this.options.idleTimeoutMillis);\n\n        if (this.options.allowExitOnIdle) {\n          // allow Node to exit if this is all that's left\n          tid.unref();\n        }\n      }\n\n      if (this.options.allowExitOnIdle) {\n        client.unref();\n      }\n\n      this._idle.push(new IdleItem(client, idleListener, tid));\n\n      this._pulseQueue();\n    }\n  }, {\n    key: \"query\",\n    value: function query(text, values, cb) {\n      var _this7 = this;\n\n      // guard clause against passing a function as the first parameter\n      if (typeof text === 'function') {\n        var _response = promisify(this.Promise, text);\n\n        setImmediate(function () {\n          return _response.callback(new Error('Passing a function as the first parameter to pool.query is not supported'));\n        });\n        return _response.result;\n      } // allow plain text query without values\n\n\n      if (typeof values === 'function') {\n        cb = values;\n        values = undefined;\n      }\n\n      var response = promisify(this.Promise, cb);\n      cb = response.callback;\n      this.connect(function (err, client) {\n        if (err) {\n          return cb(err);\n        }\n\n        var clientReleased = false;\n\n        var onError = function onError(err) {\n          if (clientReleased) {\n            return;\n          }\n\n          clientReleased = true;\n          client.release(err);\n          cb(err);\n        };\n\n        client.once('error', onError);\n\n        _this7.log('dispatching query');\n\n        try {\n          client.query(text, values, function (err, res) {\n            _this7.log('query dispatched');\n\n            client.removeListener('error', onError);\n\n            if (clientReleased) {\n              return;\n            }\n\n            clientReleased = true;\n            client.release(err);\n\n            if (err) {\n              return cb(err);\n            }\n\n            return cb(undefined, res);\n          });\n        } catch (err) {\n          client.release(err);\n          return cb(err);\n        }\n      });\n      return response.result;\n    }\n  }, {\n    key: \"end\",\n    value: function end(cb) {\n      this.log('ending');\n\n      if (this.ending) {\n        var err = new Error('Called end on pool more than once');\n        return cb ? cb(err) : this.Promise.reject(err);\n      }\n\n      this.ending = true;\n      var promised = promisify(this.Promise, cb);\n      this._endCallback = promised.callback;\n\n      this._pulseQueue();\n\n      return promised.result;\n    }\n  }, {\n    key: \"waitingCount\",\n    get: function get() {\n      return this._pendingQueue.length;\n    }\n  }, {\n    key: \"idleCount\",\n    get: function get() {\n      return this._idle.length;\n    }\n  }, {\n    key: \"expiredCount\",\n    get: function get() {\n      var _this8 = this;\n\n      return this._clients.reduce(function (acc, client) {\n        return acc + (_this8._expired.has(client) ? 1 : 0);\n      }, 0);\n    }\n  }, {\n    key: \"totalCount\",\n    get: function get() {\n      return this._clients.length;\n    }\n  }]);\n\n  return Pool;\n}(EventEmitter);\n\nmodule.exports = Pool;","map":null,"metadata":{},"sourceType":"script"}