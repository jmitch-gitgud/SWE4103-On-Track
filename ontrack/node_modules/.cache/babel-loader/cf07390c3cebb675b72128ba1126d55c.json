{"ast":null,"code":"// Copyright 2012 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n'use strict';\n\nvar assert = require('assert');\n\nvar Heap = function Heap(min) {\n  this.length = 0;\n  this.root = undefined;\n\n  if (min) {\n    this._comparator = this._smallest;\n  } else {\n    this._comparator = this._largest;\n  }\n};\n\nHeap.init = function (obj, key) {\n  obj._parent = null;\n  obj._left = null;\n  obj._right = null;\n  obj._key = key;\n  return obj;\n};\n\nHeap.prototype.count = function (node) {\n  if (!node) return 0;\n  var c = 1;\n  c += this.count(node._left);\n  c += this.count(node._right);\n  return c;\n};\n\nHeap.prototype.insert = function (obj, key) {\n  var insert, node;\n  this.length += 1;\n  node = Heap.init(obj, key);\n\n  if (!this.root) {\n    this.root = node;\n  } else {\n    insert = this._last();\n    node._parent = insert;\n    if (!insert._left) insert._left = node;else insert._right = node;\n\n    this._up(node);\n  }\n\n  this._head();\n\n  return node;\n};\n\nHeap.prototype.pop = function () {\n  var ret, last;\n  if (!this.root) return null;\n  return this.remove(this.root);\n};\n\nHeap.prototype.remove = function (node) {\n  var ret, last;\n  ret = node;\n  last = this._last();\n  if (last._right) last = last._right;else last = last._left;\n  this.length -= 1;\n\n  if (!last) {\n    if (ret == this.root) this.root = null;\n    return ret;\n  }\n\n  if (ret == last) {\n    if (ret._parent._left == node) ret._parent._left = null;else ret._parent._right = null;\n    last = ret._parent;\n    ret._parent = null;\n  } else if (!ret._left && !ret._right) {\n    // we're trying to remove an element without any children and its not the last\n    // move the last under its parent and heap-up\n    if (last._parent._left == last) last._parent._left = null;else last._parent._right = null;\n    if (ret._parent._left == ret) ret._parent._left = last;else ret._parent._right = last;\n    last._parent = ret._parent;\n    ret._parent = null; // TODO in this case we shouldn't later also do a down, but it should only visit once\n\n    this._up(last);\n  } else {\n    this._delete_swap(ret, last);\n  }\n\n  if (ret == this.root) this.root = last;\n\n  this._down(last);\n\n  this._head();\n\n  return ret;\n}; // TODO this probably isn't the most efficient way to ensure that we're always\n// at the root of the tree, but it works for now\n\n\nHeap.prototype._head = function () {\n  if (!this.root) return;\n  var tmp = this.root;\n\n  while (tmp._parent) {\n    tmp = tmp._parent;\n  }\n\n  this.root = tmp;\n}; // TODO is there a more efficient way to store this instead of an array?\n\n\nHeap.prototype._last = function () {\n  var path, pos, mod, insert;\n  pos = this.length;\n  path = [];\n\n  while (pos > 1) {\n    mod = pos % 2;\n    pos = Math.floor(pos / 2);\n    path.push(mod);\n  }\n\n  insert = this.root;\n\n  while (path.length > 1) {\n    pos = path.pop();\n    if (pos === 0) insert = insert._left;else insert = insert._right;\n  }\n\n  return insert;\n};\n\nHeap.prototype._swap = function (a, b) {\n  var cleft, cright, tparent;\n  cleft = b._left;\n  cright = b._right;\n\n  if (a._parent) {\n    if (a._parent._left == a) a._parent._left = b;else a._parent._right = b;\n  }\n\n  b._parent = a._parent;\n  a._parent = b; // This assumes direct descendents\n\n  if (a._left == b) {\n    b._left = a;\n    b._right = a._right;\n    if (b._right) b._right._parent = b;\n  } else {\n    b._right = a;\n    b._left = a._left;\n    if (b._left) b._left._parent = b;\n  }\n\n  a._left = cleft;\n  a._right = cright;\n  if (a._left) a._left._parent = a;\n  if (a._right) a._right._parent = a;\n  assert.notEqual(a._parent, a, \"A shouldn't refer to itself\");\n  assert.notEqual(b._parent, b, \"B shouldn't refer to itself\");\n};\n\nHeap.prototype._delete_swap = function (a, b) {\n  if (a._left != b) b._left = a._left;\n  if (a._right != b) b._right = a._right;\n  if (b._parent._left == b) b._parent._left = null;else b._parent._right = null;\n\n  if (a._parent) {\n    if (a._parent._left == a) a._parent._left = b;else a._parent._right = b;\n  }\n\n  b._parent = a._parent;\n  if (b._left) b._left._parent = b;\n  if (b._right) b._right._parent = b;\n  a._parent = null;\n  a._left = null;\n  a._right = null;\n};\n\nHeap.prototype._smallest = function (heap) {\n  var small = heap;\n\n  if (heap._left && heap._key > heap._left._key) {\n    small = heap._left;\n  }\n\n  if (heap._right && small._key > heap._right._key) {\n    small = heap._right;\n  }\n\n  return small;\n};\n\nHeap.prototype._largest = function (heap) {\n  var large = heap;\n\n  if (heap._left && heap._key < heap._left._key) {\n    large = heap._left;\n  }\n\n  if (heap._right && large._key < heap._right._key) {\n    large = heap._right;\n  }\n\n  return large;\n};\n\nHeap.prototype._up = function (node) {\n  if (!node || !node._parent) return;\n\n  var next = this._comparator(node._parent);\n\n  if (next != node._parent) {\n    this._swap(node._parent, node);\n\n    this._up(node);\n  }\n};\n\nHeap.prototype._down = function (node) {\n  if (!node) return;\n\n  var next = this._comparator(node);\n\n  if (next != node) {\n    this._swap(node, next);\n\n    this._down(node);\n  }\n};\n\nvar util = require('util');\n\nHeap.prototype.print = function (stream) {\n  stream.write('digraph {\\n');\n\n  Heap._print(this.root, stream);\n\n  stream.write('}\\n');\n};\n\nHeap._print = function (heap, stream) {\n  if (!heap) return;\n\n  if (heap._left) {\n    stream.write(util.format('' + heap._key, '->', heap._left._key, '\\n'));\n\n    Heap._print(heap._left, stream);\n  }\n\n  if (heap._right) {\n    stream.write(util.format('' + heap._key, '->', heap._right._key, '\\n'));\n\n    Heap._print(heap._right, stream);\n  }\n};\n\nmodule.exports = Heap;","map":null,"metadata":{},"sourceType":"script"}