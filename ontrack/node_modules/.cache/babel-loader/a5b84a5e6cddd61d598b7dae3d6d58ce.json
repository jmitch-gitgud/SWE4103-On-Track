{"ast":null,"code":"// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Server routines\nrequire('defaultable')(module, {}, function (module, exports, DEFS, require) {\n  var net = require('net');\n\n  var util = require('util');\n\n  var dgram = require('dgram');\n\n  var events = require('events');\n\n  var Message = require('./message');\n\n  var convenient = require('./convenient');\n\n  module.exports = createServer;\n\n  function createServer(handler) {\n    return new Server(handler);\n  }\n\n  util.inherits(Server, events.EventEmitter);\n\n  function Server(handler) {\n    var self = this;\n    events.EventEmitter.call(self);\n    self.log = console;\n    self.zones = {};\n    if (handler) self.on('request', handler);\n    self.udp = dgram.createSocket('udp4');\n    self.tcp = net.createServer();\n    self.udp.on('close', function () {\n      self.close();\n    });\n    self.tcp.on('close', function () {\n      self.close();\n    });\n    self.udp.on('error', function (er) {\n      self.emit('error', er);\n    });\n    self.tcp.on('error', function (er) {\n      self.emit('error', er);\n    });\n    self.tcp.on('connection', function (connection) {\n      self.on_tcp_connection(connection);\n    });\n    self.udp.on('message', function (msg, rinfo) {\n      self.on_udp(msg, rinfo);\n    });\n    var listening = {\n      'tcp': false,\n      'udp': false\n    };\n    self.udp.once('listening', function () {\n      listening.udp = true;\n      if (listening.tcp) self.emit('listening');\n    });\n    self.tcp.once('listening', function () {\n      listening.tcp = true;\n      if (listening.udp) self.emit('listening');\n    });\n  }\n\n  Server.prototype.zone = function (zone, server, admin, serial, refresh, retry, expire, ttl) {\n    var self = this,\n        record = zone;\n    if (typeof record != 'object') record = {\n      'class': 'IN',\n      'type': 'SOA',\n      'name': zone,\n      'data': {\n        'mname': server,\n        'rname': admin,\n        'serial': convenient.serial(serial),\n        'refresh': convenient.seconds(refresh),\n        'retry': convenient.seconds(retry),\n        'expire': convenient.seconds(expire),\n        'ttl': convenient.seconds(ttl || 0)\n      }\n    };\n    self.zones[record.name] = record;\n    return self;\n  };\n\n  Server.prototype.listen = function (port, ip, callback) {\n    var self = this;\n\n    if (typeof ip === 'function') {\n      callback = ip;\n      ip = null;\n    }\n\n    self.port = port;\n    self.ip = ip || '0.0.0.0';\n    if (typeof callback === 'function') self.on('listening', callback);\n    self.udp.bind(port, ip);\n    self.tcp.listen(port, ip);\n    return self;\n  };\n\n  Server.prototype.close = function () {\n    var self = this;\n    if (self.udp._receiving) self.udp.close();\n    if (self.tcp._handle) self.tcp.close(function () {\n      self.emit('close');\n    });\n  };\n\n  Server.prototype.unref = function () {\n    this.udp.unref();\n    this.tcp.unref();\n  };\n\n  Server.prototype.ref = function () {\n    this.udp.ref();\n    this.tcp.ref();\n  };\n\n  Server.prototype.on_tcp_connection = function (connection) {\n    var self = this;\n    var length = null,\n        bufs = [];\n    connection.type = 'tcp';\n    connection.server = self;\n    connection.on('data', function (data) {\n      bufs.push(data);\n      var bytes_received = bufs.reduce(function (state, buf) {\n        return state + buf.length;\n      }, 0);\n\n      if (length === null && bytes_received >= 2) {\n        var so_far = Buffer.concat(bufs); // Flatten them all together, it's probably not much data.\n\n        length = so_far.readUInt16BE(0);\n        bufs = [so_far.slice(2)];\n      }\n\n      if (length !== null && bytes_received == 2 + length) {\n        // All of the data (plus the 2-byte length prefix) is received.\n        var data = Buffer.concat(bufs),\n            req = new Request(data, connection),\n            res = new Response(data, connection);\n        self.emit('request', req, res);\n      }\n    });\n  };\n\n  Server.prototype.on_udp = function (data, rinfo) {\n    var self = this; // Provide something that feels like a net.Socket, which in turn feels like the http API.\n\n    var connection = {\n      'type': self.udp.type,\n      'remoteAddress': rinfo.address,\n      'remotePort': rinfo.port,\n      'server': self,\n      'send': function send() {\n        self.udp.send.apply(self.udp, arguments);\n      },\n      'destroy': function destroy() {},\n      'end': function end() {}\n    };\n    var req = new Request(data, connection),\n        res = new Response(data, connection);\n    self.emit('request', req, res);\n  };\n\n  util.inherits(Request, Message);\n\n  function Request(data, connection) {\n    var self = this;\n    Message.call(self, data);\n    self.connection = connection;\n  }\n\n  Request.prototype.toJSON = function () {\n    var self = this;\n    var obj = {};\n    Object.keys(self).forEach(function (key) {\n      if (key != 'connection') obj[key] = self[key];\n    });\n    return obj;\n  };\n\n  util.inherits(Response, Message);\n\n  function Response(data, connection) {\n    var self = this;\n    Message.call(self, data);\n    self.question = self.question || [];\n    self.answer = self.answer || [];\n    self.authority = self.authority || [];\n    self.additional = self.additional || [];\n    self.connection = connection;\n    convenient.init_response(self);\n  }\n\n  Response.prototype.toJSON = Request.prototype.toJSON;\n\n  Response.prototype.end = function (value) {\n    var self = this;\n    var msg = convenient.final_response(self, value),\n        data = msg.toBinary();\n    if (self.connection.type == 'udp4' && data.length > 512) return self.emit('error', 'UDP responses greater than 512 bytes not yet implemented');else if (self.connection.type == 'udp4') self.connection.send(data, 0, data.length, self.connection.remotePort, self.connection.remoteAddress, function (er) {\n      if (er) self.emit('error', er);\n    });else if (self.connection.type == 'tcp') {\n      // Add the data length prefix.\n      var length = data.length;\n      data = Buffer.concat([new Buffer([length >> 8, length & 255]), data]);\n      self.connection.end(data, function (er) {\n        if (er) self.emit('error', er);\n      });\n    } else self.emit('error', new Error('Unknown connection type: ' + self.connection.type));\n  };\n}); // defaultable","map":null,"metadata":{},"sourceType":"script"}