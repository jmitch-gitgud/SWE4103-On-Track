{"ast":null,"code":"import { File } from 'fetch-blob/from.js';\nimport { FormData } from 'formdata-polyfill/esm.min.js';\nlet s = 0;\nconst S = {\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  END: s++\n};\nlet f = 1;\nconst F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n  /**\n   * @param {string} boundary\n   */\n  constructor(boundary) {\n    this.index = 0;\n    this.flags = 0;\n    this.onHeaderEnd = noop;\n    this.onHeaderField = noop;\n    this.onHeadersEnd = noop;\n    this.onHeaderValue = noop;\n    this.onPartBegin = noop;\n    this.onPartData = noop;\n    this.onPartEnd = noop;\n    this.boundaryChars = {};\n    boundary = '\\r\\n--' + boundary;\n    const ui8a = new Uint8Array(boundary.length);\n\n    for (let i = 0; i < boundary.length; i++) {\n      ui8a[i] = boundary.charCodeAt(i);\n      this.boundaryChars[ui8a[i]] = true;\n    }\n\n    this.boundary = ui8a;\n    this.lookbehind = new Uint8Array(this.boundary.length + 8);\n    this.state = S.START_BOUNDARY;\n  }\n  /**\n   * @param {Uint8Array} data\n   */\n\n\n  write(data) {\n    let i = 0;\n    const length_ = data.length;\n    let previousIndex = this.index;\n    let {\n      lookbehind,\n      boundary,\n      boundaryChars,\n      index,\n      state,\n      flags\n    } = this;\n    const boundaryLength = this.boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    const bufferLength = data.length;\n    let c;\n    let cl;\n\n    const mark = name => {\n      this[name + 'Mark'] = i;\n    };\n\n    const clear = name => {\n      delete this[name + 'Mark'];\n    };\n\n    const callback = (callbackSymbol, start, end, ui8a) => {\n      if (start === undefined || start !== end) {\n        this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n      }\n    };\n\n    const dataCallback = (name, clear) => {\n      const markSymbol = name + 'Mark';\n\n      if (!(markSymbol in this)) {\n        return;\n      }\n\n      if (clear) {\n        callback(name, this[markSymbol], i, data);\n        delete this[markSymbol];\n      } else {\n        callback(name, this[markSymbol], data.length, data);\n        this[markSymbol] = 0;\n      }\n    };\n\n    for (i = 0; i < length_; i++) {\n      c = data[i];\n\n      switch (state) {\n        case S.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= F.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              return;\n            }\n\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n              state = S.END;\n              flags = 0;\n            } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n              callback('onPartBegin');\n              state = S.HEADER_FIELD_START;\n            } else {\n              return;\n            }\n\n            break;\n          }\n\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n\n          break;\n\n        case S.HEADER_FIELD_START:\n          state = S.HEADER_FIELD;\n          mark('onHeaderField');\n          index = 0;\n        // falls through\n\n        case S.HEADER_FIELD:\n          if (c === CR) {\n            clear('onHeaderField');\n            state = S.HEADERS_ALMOST_DONE;\n            break;\n          }\n\n          index++;\n\n          if (c === HYPHEN) {\n            break;\n          }\n\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              return;\n            }\n\n            dataCallback('onHeaderField', true);\n            state = S.HEADER_VALUE_START;\n            break;\n          }\n\n          cl = lower(c);\n\n          if (cl < A || cl > Z) {\n            return;\n          }\n\n          break;\n\n        case S.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n\n          mark('onHeaderValue');\n          state = S.HEADER_VALUE;\n        // falls through\n\n        case S.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('onHeaderValue', true);\n            callback('onHeaderEnd');\n            state = S.HEADER_VALUE_ALMOST_DONE;\n          }\n\n          break;\n\n        case S.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            return;\n          }\n\n          state = S.HEADER_FIELD_START;\n          break;\n\n        case S.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            return;\n          }\n\n          callback('onHeadersEnd');\n          state = S.PART_DATA_START;\n          break;\n\n        case S.PART_DATA_START:\n          state = S.PART_DATA;\n          mark('onPartData');\n        // falls through\n\n        case S.PART_DATA:\n          previousIndex = index;\n\n          if (index === 0) {\n            // boyer-moore derrived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n\n            while (i < bufferLength && !(data[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n\n            i -= boundaryEnd;\n            c = data[i];\n          }\n\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('onPartData', true);\n              }\n\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n\n            if (c === CR) {\n              // CR = part boundary\n              flags |= F.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= F.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & F.PART_BOUNDARY) {\n              index = 0;\n\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~F.PART_BOUNDARY;\n                callback('onPartEnd');\n                callback('onPartBegin');\n                state = S.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & F.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                callback('onPartEnd');\n                state = S.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (previousIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\n            callback('onPartData', 0, previousIndex, _lookbehind);\n            previousIndex = 0;\n            mark('onPartData'); // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n\n            i--;\n          }\n\n          break;\n\n        case S.END:\n          break;\n\n        default:\n          throw new Error(`Unexpected state entered: ${state}`);\n      }\n    }\n\n    dataCallback('onHeaderField');\n    dataCallback('onHeaderValue');\n    dataCallback('onPartData'); // Update properties for the next call\n\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n  }\n\n  end() {\n    if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n      this.onPartEnd();\n    } else if (this.state !== S.END) {\n      throw new Error('MultipartParser.end(): stream ended unexpectedly');\n    }\n  }\n\n}\n\nfunction _fileName(headerValue) {\n  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n  const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\n  if (!m) {\n    return;\n  }\n\n  const match = m[2] || m[3] || '';\n  let filename = match.slice(match.lastIndexOf('\\\\') + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n    return String.fromCharCode(code);\n  });\n  return filename;\n}\n\nexport async function toFormData(Body, ct) {\n  if (!/multipart/i.test(ct)) {\n    throw new TypeError('Failed to fetch');\n  }\n\n  const m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n  if (!m) {\n    throw new TypeError('no or bad content-type header, no multipart boundary');\n  }\n\n  const parser = new MultipartParser(m[1] || m[2]);\n  let headerField;\n  let headerValue;\n  let entryValue;\n  let entryName;\n  let contentType;\n  let filename;\n  const entryChunks = [];\n  const formData = new FormData();\n\n  const onPartData = ui8a => {\n    entryValue += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n\n  const appendToFile = ui8a => {\n    entryChunks.push(ui8a);\n  };\n\n  const appendFileToFormData = () => {\n    const file = new File(entryChunks, filename, {\n      type: contentType\n    });\n    formData.append(entryName, file);\n  };\n\n  const appendEntryToFormData = () => {\n    formData.append(entryName, entryValue);\n  };\n\n  const decoder = new TextDecoder('utf-8');\n  decoder.decode();\n\n  parser.onPartBegin = function () {\n    parser.onPartData = onPartData;\n    parser.onPartEnd = appendEntryToFormData;\n    headerField = '';\n    headerValue = '';\n    entryValue = '';\n    entryName = '';\n    contentType = '';\n    filename = null;\n    entryChunks.length = 0;\n  };\n\n  parser.onHeaderField = function (ui8a) {\n    headerField += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n\n  parser.onHeaderValue = function (ui8a) {\n    headerValue += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n\n  parser.onHeaderEnd = function () {\n    headerValue += decoder.decode();\n    headerField = headerField.toLowerCase();\n\n    if (headerField === 'content-disposition') {\n      // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n      const m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n      if (m) {\n        entryName = m[2] || m[3] || '';\n      }\n\n      filename = _fileName(headerValue);\n\n      if (filename) {\n        parser.onPartData = appendToFile;\n        parser.onPartEnd = appendFileToFormData;\n      }\n    } else if (headerField === 'content-type') {\n      contentType = headerValue;\n    }\n\n    headerValue = '';\n    headerField = '';\n  };\n\n  for await (const chunk of Body) {\n    parser.write(chunk);\n  }\n\n  parser.end();\n  return formData;\n}","map":{"version":3,"names":["File","FormData","s","S","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","END","f","F","PART_BOUNDARY","LAST_BOUNDARY","LF","CR","SPACE","HYPHEN","COLON","A","Z","lower","c","noop","MultipartParser","constructor","boundary","index","flags","onHeaderEnd","onHeaderField","onHeadersEnd","onHeaderValue","onPartBegin","onPartData","onPartEnd","boundaryChars","ui8a","Uint8Array","length","i","charCodeAt","lookbehind","state","write","data","length_","previousIndex","boundaryLength","boundaryEnd","bufferLength","cl","mark","name","clear","callback","callbackSymbol","start","end","undefined","subarray","dataCallback","markSymbol","_lookbehind","buffer","byteOffset","byteLength","Error","_fileName","headerValue","m","match","filename","slice","lastIndexOf","replace","code","String","fromCharCode","toFormData","Body","ct","test","TypeError","parser","headerField","entryValue","entryName","contentType","entryChunks","formData","decoder","decode","stream","appendToFile","push","appendFileToFormData","file","type","append","appendEntryToFormData","TextDecoder","toLowerCase","chunk"],"sources":["/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/node-fetch/src/utils/multipart-parser.js"],"sourcesContent":["import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}