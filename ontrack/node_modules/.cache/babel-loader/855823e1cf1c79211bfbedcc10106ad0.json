{"ast":null,"code":"// Copyright 2011 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n// TODO: change the default UDP packet size that node-dns sends\n//       from 4096 to conform to these:\n//       - [requestor's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.3)\n//       - [responders's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.4)\n'use strict';\n\nvar consts = require('./consts'),\n    BufferCursor = require('buffercursor'),\n    BufferCursorOverflow = BufferCursor.BufferCursorOverflow,\n    ipaddr = require('ipaddr.js'),\n    assert = require('assert'),\n    util = require('util');\n\nfunction assertUndefined(val, msg) {\n  assert(typeof val != 'undefined', msg);\n}\n\nvar Packet = module.exports = function () {\n  this.header = {\n    id: 0,\n    qr: 0,\n    opcode: 0,\n    aa: 0,\n    tc: 0,\n    rd: 1,\n    ra: 0,\n    res1: 0,\n    res2: 0,\n    res3: 0,\n    rcode: 0\n  };\n  this.question = [];\n  this.answer = [];\n  this.authority = [];\n  this.additional = [];\n  this.edns_options = []; // TODO: DEPRECATED! Use `.edns.options` instead!\n\n  this.payload = undefined; // TODO: DEPRECATED! Use `.edns.payload` instead!\n};\n\nvar LABEL_POINTER = 0xC0;\n\nvar isPointer = function isPointer(len) {\n  return (len & LABEL_POINTER) === LABEL_POINTER;\n};\n\nfunction nameUnpack(buff) {\n  var len,\n      comp,\n      end,\n      pos,\n      part,\n      combine = '';\n  len = buff.readUInt8();\n  comp = false;\n  end = buff.tell();\n\n  while (len !== 0) {\n    if (isPointer(len)) {\n      len -= LABEL_POINTER;\n      len = len << 8;\n      pos = len + buff.readUInt8();\n      if (!comp) end = buff.tell();\n      buff.seek(pos);\n      len = buff.readUInt8();\n      comp = true;\n      continue;\n    }\n\n    part = buff.toString('ascii', len);\n    if (combine.length) combine = combine + '.' + part;else combine = part;\n    len = buff.readUInt8();\n    if (!comp) end = buff.tell();\n  }\n\n  buff.seek(end);\n  return combine;\n}\n\nfunction namePack(str, buff, index) {\n  var offset, dot, part;\n\n  while (str) {\n    if (index[str]) {\n      offset = (LABEL_POINTER << 8) + index[str];\n      buff.writeUInt16BE(offset);\n      break;\n    } else {\n      index[str] = buff.tell();\n      dot = str.indexOf('.');\n\n      if (dot > -1) {\n        part = str.slice(0, dot);\n        str = str.slice(dot + 1);\n      } else {\n        part = str;\n        str = undefined;\n      }\n\n      buff.writeUInt8(part.length);\n      buff.write(part, part.length, 'ascii');\n    }\n  }\n\n  if (!str) {\n    buff.writeUInt8(0);\n  }\n}\n\nvar WRITE_HEADER = 100001,\n    WRITE_TRUNCATE = 100002,\n    WRITE_QUESTION = 100003,\n    WRITE_RESOURCE_RECORD = 100004,\n    WRITE_RESOURCE_WRITE = 100005,\n    WRITE_RESOURCE_DONE = 100006,\n    WRITE_RESOURCE_END = 100007,\n    WRITE_EDNS = 100008,\n    WRITE_END = 100009,\n    WRITE_A = consts.NAME_TO_QTYPE.A,\n    WRITE_AAAA = consts.NAME_TO_QTYPE.AAAA,\n    WRITE_NS = consts.NAME_TO_QTYPE.NS,\n    WRITE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n    WRITE_PTR = consts.NAME_TO_QTYPE.PTR,\n    WRITE_SPF = consts.NAME_TO_QTYPE.SPF,\n    WRITE_MX = consts.NAME_TO_QTYPE.MX,\n    WRITE_SRV = consts.NAME_TO_QTYPE.SRV,\n    WRITE_TXT = consts.NAME_TO_QTYPE.TXT,\n    WRITE_SOA = consts.NAME_TO_QTYPE.SOA,\n    WRITE_OPT = consts.NAME_TO_QTYPE.OPT,\n    WRITE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n    WRITE_TLSA = consts.NAME_TO_QTYPE.TLSA;\n\nfunction writeHeader(buff, packet) {\n  assert(packet.header, 'Packet requires \"header\"');\n  buff.writeUInt16BE(packet.header.id & 0xFFFF);\n  var val = 0;\n  val += packet.header.qr << 15 & 0x8000;\n  val += packet.header.opcode << 11 & 0x7800;\n  val += packet.header.aa << 10 & 0x400;\n  val += packet.header.tc << 9 & 0x200;\n  val += packet.header.rd << 8 & 0x100;\n  val += packet.header.ra << 7 & 0x80;\n  val += packet.header.res1 << 6 & 0x40;\n  val += packet.header.res2 << 5 & 0x20;\n  val += packet.header.res3 << 4 & 0x10;\n  val += packet.header.rcode & 0xF;\n  buff.writeUInt16BE(val & 0xFFFF);\n  assert(packet.question.length == 1, 'DNS requires one question'); // aren't used\n\n  buff.writeUInt16BE(1); // answer offset 6\n\n  buff.writeUInt16BE(packet.answer.length & 0xFFFF); // authority offset 8\n\n  buff.writeUInt16BE(packet.authority.length & 0xFFFF); // additional offset 10\n\n  buff.writeUInt16BE(packet.additional.length & 0xFFFF);\n  return WRITE_QUESTION;\n}\n\nfunction writeTruncate(buff, packet, section, val) {\n  // XXX FIXME TODO truncation is currently done wrong.\n  // Quote rfc2181 section 9\n  // The TC bit should not be set merely because some extra information\n  // could have been included, but there was insufficient room.  This\n  // includes the results of additional section processing.  In such cases\n  // the entire RRSet that will not fit in the response should be omitted,\n  // and the reply sent as is, with the TC bit clear.  If the recipient of\n  // the reply needs the omitted data, it can construct a query for that\n  // data and send that separately.\n  //\n  // TODO IOW only set TC if we hit it in ANSWERS otherwise make sure an\n  // entire RRSet is removed during a truncation.\n  var pos;\n  buff.seek(2);\n  val = buff.readUInt16BE();\n  val |= 1 << 9 & 0x200;\n  buff.seek(2);\n  buff.writeUInt16BE(val);\n\n  switch (section) {\n    case 'answer':\n      pos = 6; // seek to authority and clear it and additional out\n\n      buff.seek(8);\n      buff.writeUInt16BE(0);\n      buff.writeUInt16BE(0);\n      break;\n\n    case 'authority':\n      pos = 8; // seek to additional and clear it out\n\n      buff.seek(10);\n      buff.writeUInt16BE(0);\n      break;\n\n    case 'additional':\n      pos = 10;\n      break;\n  }\n\n  buff.seek(pos);\n  buff.writeUInt16BE(count - 1); // TODO: count not defined!\n\n  buff.seek(last_resource); // TODO: last_resource not defined!\n\n  return WRITE_END;\n}\n\nfunction writeQuestion(buff, val, label_index) {\n  assert(val, 'Packet requires a question');\n  assertUndefined(val.name, 'Question requires a \"name\"');\n  assertUndefined(val.type, 'Question requires a \"type\"');\n  assertUndefined(val.class, 'Questionn requires a \"class\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  return WRITE_RESOURCE_RECORD;\n}\n\nfunction writeResource(buff, val, label_index, rdata) {\n  assert(val, 'Resource must be defined');\n  assertUndefined(val.name, 'Resource record requires \"name\"');\n  assertUndefined(val.type, 'Resource record requires \"type\"');\n  assertUndefined(val.class, 'Resource record requires \"class\"');\n  assertUndefined(val.ttl, 'Resource record requires \"ttl\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  buff.writeUInt32BE(val.ttl & 0xFFFFFFFF);\n  rdata.pos = buff.tell();\n  buff.writeUInt16BE(0); // if there is rdata, then this value will be updated\n  // to the correct value by 'writeResourceDone'\n\n  return val.type;\n}\n\nfunction writeResourceDone(buff, rdata) {\n  var pos = buff.tell();\n  buff.seek(rdata.pos);\n  buff.writeUInt16BE(pos - rdata.pos - 2);\n  buff.seek(pos);\n  return WRITE_RESOURCE_RECORD;\n}\n\nfunction writeIp(buff, val) {\n  //TODO XXX FIXME -- assert that address is of proper type\n  assertUndefined(val.address, 'A/AAAA record requires \"address\"');\n  val = ipaddr.parse(val.address).toByteArray();\n  val.forEach(function (b) {\n    buff.writeUInt8(b);\n  });\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeCname(buff, val, label_index) {\n  assertUndefined(val.data, 'NS/CNAME/PTR record requires \"data\"');\n  namePack(val.data, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n} // For <character-string> see: http://tools.ietf.org/html/rfc1035#section-3.3\n// For TXT: http://tools.ietf.org/html/rfc1035#section-3.3.14\n\n\nfunction writeTxt(buff, val) {\n  //TODO XXX FIXME -- split on max char string and loop\n  assertUndefined(val.data, 'TXT record requires \"data\"');\n\n  for (var i = 0, len = val.data.length; i < len; i++) {\n    var dataLen = Buffer.byteLength(val.data[i], 'utf8');\n    buff.writeUInt8(dataLen);\n    buff.write(val.data[i], dataLen, 'utf8');\n  }\n\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeMx(buff, val, label_index) {\n  assertUndefined(val.priority, 'MX record requires \"priority\"');\n  assertUndefined(val.exchange, 'MX record requires \"exchange\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  namePack(val.exchange, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n} // SRV: https://tools.ietf.org/html/rfc2782\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\n\n\nfunction writeSrv(buff, val, label_index) {\n  assertUndefined(val.priority, 'SRV record requires \"priority\"');\n  assertUndefined(val.weight, 'SRV record requires \"weight\"');\n  assertUndefined(val.port, 'SRV record requires \"port\"');\n  assertUndefined(val.target, 'SRV record requires \"target\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  buff.writeUInt16BE(val.weight & 0xFFFF);\n  buff.writeUInt16BE(val.port & 0xFFFF);\n  namePack(val.target, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeSoa(buff, val, label_index) {\n  assertUndefined(val.primary, 'SOA record requires \"primary\"');\n  assertUndefined(val.admin, 'SOA record requires \"admin\"');\n  assertUndefined(val.serial, 'SOA record requires \"serial\"');\n  assertUndefined(val.refresh, 'SOA record requires \"refresh\"');\n  assertUndefined(val.retry, 'SOA record requires \"retry\"');\n  assertUndefined(val.expiration, 'SOA record requires \"expiration\"');\n  assertUndefined(val.minimum, 'SOA record requires \"minimum\"');\n  namePack(val.primary, buff, label_index);\n  namePack(val.admin, buff, label_index);\n  buff.writeUInt32BE(val.serial & 0xFFFFFFFF);\n  buff.writeInt32BE(val.refresh & 0xFFFFFFFF);\n  buff.writeInt32BE(val.retry & 0xFFFFFFFF);\n  buff.writeInt32BE(val.expiration & 0xFFFFFFFF);\n  buff.writeInt32BE(val.minimum & 0xFFFFFFFF);\n  return WRITE_RESOURCE_DONE;\n} // http://tools.ietf.org/html/rfc3403#section-4.1\n\n\nfunction writeNaptr(buff, val, label_index) {\n  assertUndefined(val.order, 'NAPTR record requires \"order\"');\n  assertUndefined(val.preference, 'NAPTR record requires \"preference\"');\n  assertUndefined(val.flags, 'NAPTR record requires \"flags\"');\n  assertUndefined(val.service, 'NAPTR record requires \"service\"');\n  assertUndefined(val.regexp, 'NAPTR record requires \"regexp\"');\n  assertUndefined(val.replacement, 'NAPTR record requires \"replacement\"');\n  buff.writeUInt16BE(val.order & 0xFFFF);\n  buff.writeUInt16BE(val.preference & 0xFFFF);\n  buff.writeUInt8(val.flags.length);\n  buff.write(val.flags, val.flags.length, 'ascii');\n  buff.writeUInt8(val.service.length);\n  buff.write(val.service, val.service.length, 'ascii');\n  buff.writeUInt8(val.regexp.length);\n  buff.write(val.regexp, val.regexp.length, 'ascii');\n  namePack(val.replacement, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n} // https://tools.ietf.org/html/rfc6698\n\n\nfunction writeTlsa(buff, val) {\n  assertUndefined(val.usage, 'TLSA record requires \"usage\"');\n  assertUndefined(val.selector, 'TLSA record requires \"selector\"');\n  assertUndefined(val.matchingtype, 'TLSA record requires \"matchingtype\"');\n  assertUndefined(val.buff, 'TLSA record requires \"buff\"');\n  buff.writeUInt8(val.usage);\n  buff.writeUInt8(val.selector);\n  buff.writeUInt8(val.matchingtype);\n  buff.copy(val.buff);\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction makeEdns(packet) {\n  packet.edns = {\n    name: '',\n    type: consts.NAME_TO_QTYPE.OPT,\n    class: packet.payload,\n    options: [],\n    ttl: 0\n  };\n  packet.edns_options = packet.edns.options; // TODO: 'edns_options' is DEPRECATED!\n\n  packet.additional.push(packet.edns);\n  return WRITE_HEADER;\n}\n\nfunction writeOpt(buff, val) {\n  var opt;\n\n  for (var i = 0, len = val.options.length; i < len; i++) {\n    opt = val.options[i];\n    buff.writeUInt16BE(opt.code);\n    buff.writeUInt16BE(opt.data.length);\n    buff.copy(opt.data);\n  }\n\n  return WRITE_RESOURCE_DONE;\n}\n\nPacket.write = function (buff, packet) {\n  var state = WRITE_HEADER,\n      val,\n      section,\n      count,\n      rdata,\n      last_resource,\n      label_index = {};\n  buff = new BufferCursor(buff); // the existence of 'edns' in a packet indicates that a proper OPT record exists\n  // in 'additional' and that all of the other fields in packet (that are parsed by\n  // 'parseOpt') are properly set. If it does not exist, we assume that the user\n  // is requesting that we create one for them.\n\n  if (typeof packet.edns_version !== 'undefined' && typeof packet.edns === \"undefined\") state = makeEdns(packet); // TODO: this is unnecessarily inefficient. rewrite this using a\n  //       function table instead. (same for Packet.parse too).\n\n  while (true) {\n    try {\n      switch (state) {\n        case WRITE_HEADER:\n          state = writeHeader(buff, packet);\n          break;\n\n        case WRITE_TRUNCATE:\n          state = writeTruncate(buff, packet, section, last_resource);\n          break;\n\n        case WRITE_QUESTION:\n          state = writeQuestion(buff, packet.question[0], label_index);\n          section = 'answer';\n          count = 0;\n          break;\n\n        case WRITE_RESOURCE_RECORD:\n          last_resource = buff.tell();\n\n          if (packet[section].length == count) {\n            switch (section) {\n              case 'answer':\n                section = 'authority';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n\n              case 'authority':\n                section = 'additional';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n\n              case 'additional':\n                state = WRITE_END;\n                break;\n            }\n\n            count = 0;\n          } else {\n            state = WRITE_RESOURCE_WRITE;\n          }\n\n          break;\n\n        case WRITE_RESOURCE_WRITE:\n          rdata = {};\n          val = packet[section][count];\n          state = writeResource(buff, val, label_index, rdata);\n          break;\n\n        case WRITE_RESOURCE_DONE:\n          count += 1;\n          state = writeResourceDone(buff, rdata);\n          break;\n\n        case WRITE_A:\n        case WRITE_AAAA:\n          state = writeIp(buff, val);\n          break;\n\n        case WRITE_NS:\n        case WRITE_CNAME:\n        case WRITE_PTR:\n          state = writeCname(buff, val, label_index);\n          break;\n\n        case WRITE_SPF:\n        case WRITE_TXT:\n          state = writeTxt(buff, val);\n          break;\n\n        case WRITE_MX:\n          state = writeMx(buff, val, label_index);\n          break;\n\n        case WRITE_SRV:\n          state = writeSrv(buff, val, label_index);\n          break;\n\n        case WRITE_SOA:\n          state = writeSoa(buff, val, label_index);\n          break;\n\n        case WRITE_OPT:\n          state = writeOpt(buff, val);\n          break;\n\n        case WRITE_NAPTR:\n          state = writeNaptr(buff, val, label_index);\n          break;\n\n        case WRITE_TLSA:\n          state = writeTlsa(buff, val);\n          break;\n\n        case WRITE_END:\n          return buff.tell();\n\n        default:\n          if (typeof val.data !== 'object') throw new Error('Packet.write Unknown State: ' + state); // write unhandled RR type\n\n          buff.copy(val.data);\n          state = WRITE_RESOURCE_DONE;\n      }\n    } catch (e) {\n      if (e instanceof BufferCursorOverflow) {\n        state = WRITE_TRUNCATE;\n      } else {\n        throw e;\n      }\n    }\n  }\n};\n\nfunction parseHeader(msg, packet) {\n  packet.header.id = msg.readUInt16BE();\n  var val = msg.readUInt16BE();\n  packet.header.qr = (val & 0x8000) >> 15;\n  packet.header.opcode = (val & 0x7800) >> 11;\n  packet.header.aa = (val & 0x400) >> 10;\n  packet.header.tc = (val & 0x200) >> 9;\n  packet.header.rd = (val & 0x100) >> 8;\n  packet.header.ra = (val & 0x80) >> 7;\n  packet.header.res1 = (val & 0x40) >> 6;\n  packet.header.res2 = (val & 0x20) >> 5;\n  packet.header.res3 = (val & 0x10) >> 4;\n  packet.header.rcode = val & 0xF;\n  packet.question = new Array(msg.readUInt16BE());\n  packet.answer = new Array(msg.readUInt16BE());\n  packet.authority = new Array(msg.readUInt16BE());\n  packet.additional = new Array(msg.readUInt16BE());\n  return PARSE_QUESTION;\n}\n\nfunction parseQuestion(msg, packet) {\n  var val = {};\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  packet.question[0] = val;\n  assert(packet.question.length === 1); // TODO handle qdcount > 1 in practice no one sends this\n\n  return PARSE_RESOURCE_RECORD;\n}\n\nfunction parseRR(msg, val, rdata) {\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  val.ttl = msg.readUInt32BE();\n  rdata.len = msg.readUInt16BE();\n  return val.type;\n}\n\nfunction parseA(val, msg) {\n  var address = '' + msg.readUInt8() + '.' + msg.readUInt8() + '.' + msg.readUInt8() + '.' + msg.readUInt8();\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseAAAA(val, msg) {\n  var address = '';\n  var compressed = false;\n\n  for (var i = 0; i < 8; i++) {\n    if (i > 0) address += ':'; // TODO zero compression\n\n    address += msg.readUInt16BE().toString(16);\n  }\n\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseCname(val, msg) {\n  val.data = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseTxt(val, msg, rdata) {\n  val.data = [];\n  var end = msg.tell() + rdata.len;\n\n  while (msg.tell() != end) {\n    var len = msg.readUInt8();\n    val.data.push(msg.toString('utf8', len));\n  }\n\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseMx(val, msg, rdata) {\n  val.priority = msg.readUInt16BE();\n  val.exchange = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n} // TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\n//       https://tools.ietf.org/html/rfc2782\n\n\nfunction parseSrv(val, msg) {\n  val.priority = msg.readUInt16BE();\n  val.weight = msg.readUInt16BE();\n  val.port = msg.readUInt16BE();\n  val.target = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseSoa(val, msg) {\n  val.primary = nameUnpack(msg);\n  val.admin = nameUnpack(msg);\n  val.serial = msg.readUInt32BE();\n  val.refresh = msg.readInt32BE();\n  val.retry = msg.readInt32BE();\n  val.expiration = msg.readInt32BE();\n  val.minimum = msg.readInt32BE();\n  return PARSE_RESOURCE_DONE;\n} // http://tools.ietf.org/html/rfc3403#section-4.1\n\n\nfunction parseNaptr(val, msg) {\n  val.order = msg.readUInt16BE();\n  val.preference = msg.readUInt16BE();\n  var len = msg.readUInt8();\n  val.flags = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.service = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.regexp = msg.toString('ascii', len);\n  val.replacement = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseTlsa(val, msg, rdata) {\n  val.usage = msg.readUInt8();\n  val.selector = msg.readUInt8();\n  val.matchingtype = msg.readUInt8();\n  val.buff = msg.slice(rdata.len - 3).buffer; // 3 because of the 3 UInt8s above.\n\n  return PARSE_RESOURCE_DONE;\n} // https://tools.ietf.org/html/rfc6891#section-6.1.2\n// https://tools.ietf.org/html/rfc2671#section-4.4\n//       - [payload size selection](https://tools.ietf.org/html/rfc6891#section-6.2.5)\n\n\nfunction parseOpt(val, msg, rdata, packet) {\n  // assert first entry in additional\n  rdata.buf = msg.slice(rdata.len);\n  val.rcode = ((val.ttl & 0xFF000000) >> 20) + packet.header.rcode;\n  val.version = val.ttl >> 16 & 0xFF;\n  val.do = val.ttl >> 15 & 1;\n  val.z = val.ttl & 0x7F;\n  val.options = [];\n  packet.edns = val;\n  packet.edns_version = val.version; // TODO: return BADVERS for unsupported version! (Section 6.1.3)\n  // !! BEGIN DEPRECATION NOTICE !!\n  // THESE FIELDS MAY BE REMOVED IN THE FUTURE!\n\n  packet.edns_options = val.options;\n  packet.payload = val.class; // !! END DEPRECATION NOTICE !!\n\n  while (!rdata.buf.eof()) {\n    val.options.push({\n      code: rdata.buf.readUInt16BE(),\n      data: rdata.buf.slice(rdata.buf.readUInt16BE()).buffer\n    });\n  }\n\n  return PARSE_RESOURCE_DONE;\n}\n\nvar PARSE_HEADER = 100000,\n    PARSE_QUESTION = 100001,\n    PARSE_RESOURCE_RECORD = 100002,\n    PARSE_RR_UNPACK = 100003,\n    PARSE_RESOURCE_DONE = 100004,\n    PARSE_END = 100005,\n    PARSE_A = consts.NAME_TO_QTYPE.A,\n    PARSE_NS = consts.NAME_TO_QTYPE.NS,\n    PARSE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n    PARSE_SOA = consts.NAME_TO_QTYPE.SOA,\n    PARSE_PTR = consts.NAME_TO_QTYPE.PTR,\n    PARSE_MX = consts.NAME_TO_QTYPE.MX,\n    PARSE_TXT = consts.NAME_TO_QTYPE.TXT,\n    PARSE_AAAA = consts.NAME_TO_QTYPE.AAAA,\n    PARSE_SRV = consts.NAME_TO_QTYPE.SRV,\n    PARSE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n    PARSE_OPT = consts.NAME_TO_QTYPE.OPT,\n    PARSE_SPF = consts.NAME_TO_QTYPE.SPF,\n    PARSE_TLSA = consts.NAME_TO_QTYPE.TLSA;\n\nPacket.parse = function (msg) {\n  var state, pos, val, rdata, section, count;\n  var packet = new Packet();\n  pos = 0;\n  state = PARSE_HEADER;\n  msg = new BufferCursor(msg);\n\n  while (true) {\n    switch (state) {\n      case PARSE_HEADER:\n        state = parseHeader(msg, packet);\n        break;\n\n      case PARSE_QUESTION:\n        state = parseQuestion(msg, packet);\n        section = 'answer';\n        count = 0;\n        break;\n\n      case PARSE_RESOURCE_RECORD:\n        // console.log('PARSE_RESOURCE_RECORD: count = %d, %s.len = %d', count, section, packet[section].length);\n        if (count === packet[section].length) {\n          switch (section) {\n            case 'answer':\n              section = 'authority';\n              count = 0;\n              break;\n\n            case 'authority':\n              section = 'additional';\n              count = 0;\n              break;\n\n            case 'additional':\n              state = PARSE_END;\n              break;\n          }\n        } else {\n          state = PARSE_RR_UNPACK;\n        }\n\n        break;\n\n      case PARSE_RR_UNPACK:\n        val = {};\n        rdata = {};\n        state = parseRR(msg, val, rdata);\n        break;\n\n      case PARSE_RESOURCE_DONE:\n        packet[section][count++] = val;\n        state = PARSE_RESOURCE_RECORD;\n        break;\n\n      case PARSE_A:\n        state = parseA(val, msg);\n        break;\n\n      case PARSE_AAAA:\n        state = parseAAAA(val, msg);\n        break;\n\n      case PARSE_NS:\n      case PARSE_CNAME:\n      case PARSE_PTR:\n        state = parseCname(val, msg);\n        break;\n\n      case PARSE_SPF:\n      case PARSE_TXT:\n        state = parseTxt(val, msg, rdata);\n        break;\n\n      case PARSE_MX:\n        state = parseMx(val, msg);\n        break;\n\n      case PARSE_SRV:\n        state = parseSrv(val, msg);\n        break;\n\n      case PARSE_SOA:\n        state = parseSoa(val, msg);\n        break;\n\n      case PARSE_OPT:\n        state = parseOpt(val, msg, rdata, packet);\n        break;\n\n      case PARSE_NAPTR:\n        state = parseNaptr(val, msg);\n        break;\n\n      case PARSE_TLSA:\n        state = parseTlsa(val, msg, rdata);\n        break;\n\n      case PARSE_END:\n        return packet;\n\n      default:\n        //console.log(state, val);\n        val.data = msg.slice(rdata.len);\n        state = PARSE_RESOURCE_DONE;\n        break;\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}