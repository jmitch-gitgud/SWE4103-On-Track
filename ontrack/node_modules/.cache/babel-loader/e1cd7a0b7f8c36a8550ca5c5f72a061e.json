{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar net = require('net');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar _require = require('pg-protocol'),\n    parse = _require.parse,\n    serialize = _require.serialize;\n\nvar flushBuffer = serialize.flush();\nvar syncBuffer = serialize.sync();\nvar endBuffer = serialize.end(); // TODO(bmc) support binary mode at some point\n\nvar Connection = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Connection, _EventEmitter);\n\n  function Connection(config) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connection).call(this));\n    config = config || {};\n    _this.stream = config.stream || new net.Socket();\n    _this._keepAlive = config.keepAlive;\n    _this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;\n    _this.lastBuffer = false;\n    _this.parsedStatements = {};\n    _this.ssl = config.ssl || false;\n    _this._ending = false;\n    _this._emitMessage = false;\n\n    var self = _assertThisInitialized(_assertThisInitialized(_this));\n\n    _this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true;\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"connect\",\n    value: function connect(port, host) {\n      var self = this;\n      this._connecting = true;\n      this.stream.setNoDelay(true);\n      this.stream.connect(port, host);\n      this.stream.once('connect', function () {\n        if (self._keepAlive) {\n          self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);\n        }\n\n        self.emit('connect');\n      });\n\n      var reportStreamError = function reportStreamError(error) {\n        // errors about disconnections should be ignored during disconnect\n        if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n          return;\n        }\n\n        self.emit('error', error);\n      };\n\n      this.stream.on('error', reportStreamError);\n      this.stream.on('close', function () {\n        self.emit('end');\n      });\n\n      if (!this.ssl) {\n        return this.attachListeners(this.stream);\n      }\n\n      this.stream.once('data', function (buffer) {\n        var responseCode = buffer.toString('utf8');\n\n        switch (responseCode) {\n          case 'S':\n            // Server supports SSL connections, continue with a secure connection\n            break;\n\n          case 'N':\n            // Server does not support SSL connections\n            self.stream.end();\n            return self.emit('error', new Error('The server does not support SSL connections'));\n\n          default:\n            // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n            self.stream.end();\n            return self.emit('error', new Error('There was an error establishing an SSL connection'));\n        }\n\n        var tls = require('tls');\n\n        var options = {\n          socket: self.stream\n        };\n\n        if (self.ssl !== true) {\n          Object.assign(options, self.ssl);\n\n          if ('key' in self.ssl) {\n            options.key = self.ssl.key;\n          }\n        }\n\n        if (net.isIP(host) === 0) {\n          options.servername = host;\n        }\n\n        try {\n          self.stream = tls.connect(options);\n        } catch (err) {\n          return self.emit('error', err);\n        }\n\n        self.attachListeners(self.stream);\n        self.stream.on('error', reportStreamError);\n        self.emit('sslconnect');\n      });\n    }\n  }, {\n    key: \"attachListeners\",\n    value: function attachListeners(stream) {\n      var _this2 = this;\n\n      stream.on('end', function () {\n        _this2.emit('end');\n      });\n      parse(stream, function (msg) {\n        var eventName = msg.name === 'error' ? 'errorMessage' : msg.name;\n\n        if (_this2._emitMessage) {\n          _this2.emit('message', msg);\n        }\n\n        _this2.emit(eventName, msg);\n      });\n    }\n  }, {\n    key: \"requestSsl\",\n    value: function requestSsl() {\n      this.stream.write(serialize.requestSsl());\n    }\n  }, {\n    key: \"startup\",\n    value: function startup(config) {\n      this.stream.write(serialize.startup(config));\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(processID, secretKey) {\n      this._send(serialize.cancel(processID, secretKey));\n    }\n  }, {\n    key: \"password\",\n    value: function password(_password) {\n      this._send(serialize.password(_password));\n    }\n  }, {\n    key: \"sendSASLInitialResponseMessage\",\n    value: function sendSASLInitialResponseMessage(mechanism, initialResponse) {\n      this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));\n    }\n  }, {\n    key: \"sendSCRAMClientFinalMessage\",\n    value: function sendSCRAMClientFinalMessage(additionalData) {\n      this._send(serialize.sendSCRAMClientFinalMessage(additionalData));\n    }\n  }, {\n    key: \"_send\",\n    value: function _send(buffer) {\n      if (!this.stream.writable) {\n        return false;\n      }\n\n      return this.stream.write(buffer);\n    }\n  }, {\n    key: \"query\",\n    value: function query(text) {\n      this._send(serialize.query(text));\n    } // send parse message\n\n  }, {\n    key: \"parse\",\n    value: function parse(query) {\n      this._send(serialize.parse(query));\n    } // send bind message\n\n  }, {\n    key: \"bind\",\n    value: function bind(config) {\n      this._send(serialize.bind(config));\n    } // send execute message\n\n  }, {\n    key: \"execute\",\n    value: function execute(config) {\n      this._send(serialize.execute(config));\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      if (this.stream.writable) {\n        this.stream.write(flushBuffer);\n      }\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      this._ending = true;\n\n      this._send(flushBuffer);\n\n      this._send(syncBuffer);\n    }\n  }, {\n    key: \"ref\",\n    value: function ref() {\n      this.stream.ref();\n    }\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      this.stream.unref();\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      var _this3 = this;\n\n      // 0x58 = 'X'\n      this._ending = true;\n\n      if (!this._connecting || !this.stream.writable) {\n        this.stream.end();\n        return;\n      }\n\n      return this.stream.write(endBuffer, function () {\n        _this3.stream.end();\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(msg) {\n      this._send(serialize.close(msg));\n    }\n  }, {\n    key: \"describe\",\n    value: function describe(msg) {\n      this._send(serialize.describe(msg));\n    }\n  }, {\n    key: \"sendCopyFromChunk\",\n    value: function sendCopyFromChunk(chunk) {\n      this._send(serialize.copyData(chunk));\n    }\n  }, {\n    key: \"endCopyFrom\",\n    value: function endCopyFrom() {\n      this._send(serialize.copyDone());\n    }\n  }, {\n    key: \"sendCopyFail\",\n    value: function sendCopyFail(msg) {\n      this._send(serialize.copyFail(msg));\n    }\n  }]);\n\n  return Connection;\n}(EventEmitter);\n\nmodule.exports = Connection;","map":null,"metadata":{},"sourceType":"script"}