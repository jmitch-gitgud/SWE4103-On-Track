{"ast":null,"code":"var parseInt64 = require('pg-int8');\n\nvar parseBits = function parseBits(data, bits, offset, invert, callback) {\n  offset = offset || 0;\n  invert = invert || false;\n\n  callback = callback || function (lastValue, newValue, bits) {\n    return lastValue * Math.pow(2, bits) + newValue;\n  };\n\n  var offsetBytes = offset >> 3;\n\n  var inv = function inv(value) {\n    if (invert) {\n      return ~value & 0xff;\n    }\n\n    return value;\n  }; // read first (maybe partial) byte\n\n\n  var mask = 0xff;\n  var firstBits = 8 - offset % 8;\n\n  if (bits < firstBits) {\n    mask = 0xff << 8 - bits & 0xff;\n    firstBits = bits;\n  }\n\n  if (offset) {\n    mask = mask >> offset % 8;\n  }\n\n  var result = 0;\n\n  if (offset % 8 + bits >= 8) {\n    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);\n  } // read bytes\n\n\n  var bytes = bits + offset >> 3;\n\n  for (var i = offsetBytes + 1; i < bytes; i++) {\n    result = callback(result, inv(data[i]), 8);\n  } // bits to read, that are not a complete byte\n\n\n  var lastBits = (bits + offset) % 8;\n\n  if (lastBits > 0) {\n    result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);\n  }\n\n  return result;\n};\n\nvar parseFloatFromBits = function parseFloatFromBits(data, precisionBits, exponentBits) {\n  var bias = Math.pow(2, exponentBits - 1) - 1;\n  var sign = parseBits(data, 1);\n  var exponent = parseBits(data, exponentBits, 1);\n\n  if (exponent === 0) {\n    return 0;\n  } // parse mantissa\n\n\n  var precisionBitsCounter = 1;\n\n  var parsePrecisionBits = function parsePrecisionBits(lastValue, newValue, bits) {\n    if (lastValue === 0) {\n      lastValue = 1;\n    }\n\n    for (var i = 1; i <= bits; i++) {\n      precisionBitsCounter /= 2;\n\n      if ((newValue & 0x1 << bits - i) > 0) {\n        lastValue += precisionBitsCounter;\n      }\n    }\n\n    return lastValue;\n  };\n\n  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits); // special cases\n\n  if (exponent == Math.pow(2, exponentBits + 1) - 1) {\n    if (mantissa === 0) {\n      return sign === 0 ? Infinity : -Infinity;\n    }\n\n    return NaN;\n  } // normale number\n\n\n  return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;\n};\n\nvar parseInt16 = function parseInt16(value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 15, 1, true) + 1);\n  }\n\n  return parseBits(value, 15, 1);\n};\n\nvar parseInt32 = function parseInt32(value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 31, 1, true) + 1);\n  }\n\n  return parseBits(value, 31, 1);\n};\n\nvar parseFloat32 = function parseFloat32(value) {\n  return parseFloatFromBits(value, 23, 8);\n};\n\nvar parseFloat64 = function parseFloat64(value) {\n  return parseFloatFromBits(value, 52, 11);\n};\n\nvar parseNumeric = function parseNumeric(value) {\n  var sign = parseBits(value, 16, 32);\n\n  if (sign == 0xc000) {\n    return NaN;\n  }\n\n  var weight = Math.pow(10000, parseBits(value, 16, 16));\n  var result = 0;\n  var digits = [];\n  var ndigits = parseBits(value, 16);\n\n  for (var i = 0; i < ndigits; i++) {\n    result += parseBits(value, 16, 64 + 16 * i) * weight;\n    weight /= 10000;\n  }\n\n  var scale = Math.pow(10, parseBits(value, 16, 48));\n  return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;\n};\n\nvar parseDate = function parseDate(isUTC, value) {\n  var sign = parseBits(value, 1);\n  var rawValue = parseBits(value, 63, 1); // discard usecs and shift from 2000 to 1970\n\n  var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);\n\n  if (!isUTC) {\n    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);\n  } // add microseconds to the date\n\n\n  result.usec = rawValue % 1000;\n\n  result.getMicroSeconds = function () {\n    return this.usec;\n  };\n\n  result.setMicroSeconds = function (value) {\n    this.usec = value;\n  };\n\n  result.getUTCMicroSeconds = function () {\n    return this.usec;\n  };\n\n  return result;\n};\n\nvar parseArray = function parseArray(value) {\n  var dim = parseBits(value, 32);\n  var flags = parseBits(value, 32, 32);\n  var elementType = parseBits(value, 32, 64);\n  var offset = 96;\n  var dims = [];\n\n  for (var i = 0; i < dim; i++) {\n    // parse dimension\n    dims[i] = parseBits(value, 32, offset);\n    offset += 32; // ignore lower bounds\n\n    offset += 32;\n  }\n\n  var parseElement = function parseElement(elementType) {\n    // parse content length\n    var length = parseBits(value, 32, offset);\n    offset += 32; // parse null values\n\n    if (length == 0xffffffff) {\n      return null;\n    }\n\n    var result;\n\n    if (elementType == 0x17 || elementType == 0x14) {\n      // int/bigint\n      result = parseBits(value, length * 8, offset);\n      offset += length * 8;\n      return result;\n    } else if (elementType == 0x19) {\n      // string\n      result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);\n      return result;\n    } else {\n      console.log(\"ERROR: ElementType not implemented: \" + elementType);\n    }\n  };\n\n  var parse = function parse(dimension, elementType) {\n    var array = [];\n    var i;\n\n    if (dimension.length > 1) {\n      var count = dimension.shift();\n\n      for (i = 0; i < count; i++) {\n        array[i] = parse(dimension, elementType);\n      }\n\n      dimension.unshift(count);\n    } else {\n      for (i = 0; i < dimension[0]; i++) {\n        array[i] = parseElement(elementType);\n      }\n    }\n\n    return array;\n  };\n\n  return parse(dims, elementType);\n};\n\nvar parseText = function parseText(value) {\n  return value.toString('utf8');\n};\n\nvar parseBool = function parseBool(value) {\n  if (value === null) return null;\n  return parseBits(value, 8) > 0;\n};\n\nvar init = function init(register) {\n  register(20, parseInt64);\n  register(21, parseInt16);\n  register(23, parseInt32);\n  register(26, parseInt32);\n  register(1700, parseNumeric);\n  register(700, parseFloat32);\n  register(701, parseFloat64);\n  register(16, parseBool);\n  register(1114, parseDate.bind(null, false));\n  register(1184, parseDate.bind(null, true));\n  register(1000, parseArray);\n  register(1007, parseArray);\n  register(1016, parseArray);\n  register(1008, parseArray);\n  register(1009, parseArray);\n  register(25, parseText);\n};\n\nmodule.exports = {\n  init: init\n};","map":null,"metadata":{},"sourceType":"script"}