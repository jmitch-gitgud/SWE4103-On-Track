{"ast":null,"code":"// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Test displaying DNS records\nvar util = require('util');\n\nvar parse = require('./parse');\n\nvar encode = require('./encode');\n\nvar constants = require('./constants');\n\nmodule.exports = DNSMessage;\nvar SECTIONS = ['question', 'answer', 'authority', 'additional']; // A DNS message.  This is an easy-to-understand object representation of\n// standard DNS queries and responses.\n//\n// Attributes:\n// * id                  - a number representing the unique query ID\n// * type                - \"request\" or \"response\"\n// * response            - Number (server response code)\n// * opcode              - \"query\", \"iquery\", \"status\", \"unassigned\", \"notify\", \"update\"\n// * authoritative       - Boolean\n// * truncated           - Boolean\n// * recursion_desired   - Boolean\n// * recursion_available - Boolean\n// * authenticated       - Boolean\n// * checking_disabled   - Boolean\n//\n// Optional attributes:\n// * question (optional) - Array of the question section\n// * answer (optional) - Array of the answer section\n// * authority (optional) - Array of the authority section\n// * additional (optional) - Array of the additional section\n//\n// Methods:\n// * toString() - return a human-readable representation of this message\n// * toJSON() - Return a JSON-friendly represenation of this message\n// * toBinary() - Return a buffer of the encoded message\n\nfunction DNSMessage(body) {\n  var self = this;\n  this.id = null;\n  this.type = null;\n  this.responseCode = null;\n  this.opcode = null;\n  this.authoritative = null;\n  this.truncated = null;\n  this.recursion_desired = null;\n  this.recursion_available = null;\n  this.authenticated = null;\n  this.checking_disabled = null;\n  if (Buffer.isBuffer(body)) this.parse(body);else if (typeof body != 'object') throw new Error('Must provide a buffer or object argument with message contents');else {\n    Object.keys(body).forEach(function (key) {\n      self[key] = body[key];\n    });\n    SECTIONS.forEach(function (section) {\n      if (self[section]) self[section].forEach(function (record, i) {\n        self[section][i] = new DNSRecord(record);\n      });\n    });\n  } // EDNS processing. For now, just remove those records.\n\n  SECTIONS.forEach(function (section) {\n    if (self[section]) {\n      self[section] = self[section].filter(function (record) {\n        return !record.edns;\n      });\n      if (self[section].length == 0) delete self[section];\n    }\n  });\n}\n\nDNSMessage.prototype.parse = function (body) {\n  var self = this;\n  self.id = parse.id(body);\n  var qr = parse.qr(body);\n  self.type = qr == 0 ? 'request' : 'response';\n  self.responseCode = parse.rcode(body);\n  var opcode_names = ['query', 'iquery', 'status', null, 'notify', 'update'];\n  var opcode = parse.opcode(body);\n  self.opcode = opcode_names[opcode] || null;\n  self.authoritative = !!parse.aa(body);\n  self.truncated = !!parse.tc(body);\n  self.recursion_desired = !!parse.rd(body);\n  self.recursion_available = !!parse.ra(body);\n  self.authenticated = !!parse.ad(body);\n  self.checking_disabled = !!parse.cd(body);\n  var sections_cache = parse.sections(body);\n  SECTIONS.forEach(function (section) {\n    var count = parse.record_count(body, section);\n\n    if (count) {\n      self[section] = [];\n\n      for (var i = 0; i < count; i++) {\n        self[section].push(new DNSRecord(body, section, i, sections_cache));\n      }\n    }\n  });\n};\n\nDNSMessage.prototype.toBinary = function () {\n  // The encoder is picky, so make sure it gets a valid message.\n  var msg = JSON.parse(JSON.stringify(this));\n  SECTIONS.forEach(function (section) {\n    if (section == 'question') return;\n    msg[section] = msg[section] || [];\n    msg[section].forEach(function (record) {\n      if (record.class != 'IN') return; // Make sure records promising data have data.\n\n      if (record.class == 'IN' && record.type == 'A') record.data = record.data || '0.0.0.0'; // Convert SOA email addresses back to the dotted notation.\n\n      if (record.class == 'IN' && record.type == 'SOA') record.data.rname = record.data.rname.replace(/@/g, '.'); // Normalize TXT records.\n\n      if (record.type == 'TXT' && typeof record.data == 'string') record.data = [record.data];\n    });\n  });\n  var state = new encode.State();\n  state.message(msg);\n  return state.toBinary();\n};\n\nDNSMessage.prototype.toString = function () {\n  var self = this;\n  var info = [util.format('ID                 : %d', self.id), util.format(\"Type               : %s\", self.type), util.format(\"Opcode             : %s\", self.opcode), util.format(\"Authoritative      : %s\", self.authoritative), util.format(\"Truncated          : %s\", self.truncated), util.format(\"Recursion Desired  : %s\", self.recursion_desired), util.format(\"Recursion Available: %s\", self.recursion_available), util.format(\"Response Code      : %d\", self.responseCode)];\n  SECTIONS.forEach(function (section) {\n    if (self[section]) {\n      info.push(util.format(';; %s SECTION:', section.toUpperCase()));\n      self[section].forEach(function (record) {\n        info.push(record.toString());\n      });\n    }\n  });\n  return info.join('\\n');\n}; // An individual record from a DNS message\n//\n// Attributes:\n// * name  - Host name\n// * type  - Query type ('A', 'NS', 'CNAME', etc. or 'Unknown')\n// * class - Network class ('IN', 'None' 'Unknown')\n// * ttl   - Time to live for the data in the record\n// * data  - The record data value, or null if not applicable\n\n\nfunction DNSRecord(body, section_name, record_num, sections_cache) {\n  var self = this;\n  this.name = null;\n  this.type = null;\n  this.class = null; // Leave these undefined for more consice and clear JSON serialization.\n  //this.ttl  = null\n  //this.data = null\n\n  if (Buffer.isBuffer(body)) this.parse(body, section_name, record_num, sections_cache || body);else if (typeof body != 'object') throw new Error('Must provide a buffer or object argument with message contents');else Object.keys(body).forEach(function (key) {\n    self[key] = body[key];\n  });\n}\n\nDNSRecord.prototype.parse = function (body, section_name, record_num, sections) {\n  var self = this;\n  self.name = parse.record_name(sections, section_name, record_num);\n  var type = parse.record_type(sections, section_name, record_num);\n  self.type = constants.type_to_label(type);\n  if (!self.type) throw new Error('Record ' + record_num + ' in section \"' + section_name + '\" has unknown type: ' + type);\n\n  if (section_name != 'additional' || self.type != 'OPT' || self.name != '') {\n    // Normal record\n    var clas = parse.record_class(sections, section_name, record_num);\n    self.class = constants.class_to_label(clas);\n    if (!self.class) throw new Error('Record ' + record_num + ' in section \"' + section_name + '\" has unknown class: ' + type);\n    if (section_name == 'question') return;else self.ttl = parse.record_ttl(sections, section_name, record_num);\n  } else {\n    // EDNS record\n    self.edns = true;\n    delete self.name;\n    delete self.class; //self.edns = parse.record_edns(sections, section_name, record_num)\n  }\n\n  var rdata = parse.record_data(sections, section_name, record_num);\n\n  switch (self.kind()) {\n    case 'IN A':\n      if (rdata.length != 4) throw new Error('Bad IN A data: ' + JSON.stringify(self));\n      self.data = inet_ntoa(rdata);\n      break;\n\n    case 'IN AAAA':\n      if (rdata.length != 16) throw new Error('Bad IN AAAA data: ' + JSON.stringify(self));\n      self.data = inet_ntoa6(rdata);\n      break;\n\n    case 'IN NS':\n    case 'IN CNAME':\n    case 'IN PTR':\n      self.data = parse.uncompress(body, rdata);\n      break;\n\n    case 'IN TXT':\n      self.data = parse.txt(body, rdata);\n      if (self.data.length === 0) self.data = '';else if (self.data.length === 1) self.data = self.data[0];\n      break;\n\n    case 'IN MX':\n      self.data = parse.mx(body, rdata);\n      break;\n\n    case 'IN SRV':\n      self.data = parse.srv(body, rdata);\n      break;\n\n    case 'IN SOA':\n      self.data = parse.soa(body, rdata);\n      self.data.rname = self.data.rname.replace(/\\./, '@');\n      break;\n\n    case 'IN DS':\n      self.data = {\n        'key_tag': rdata[0] << 8 | rdata[1],\n        'algorithm': rdata[2],\n        'digest_type': rdata[3],\n        'digest': rdata.slice(4).toJSON() // Convert to a list of numbers.\n\n      };\n      break;\n\n    case 'NONE A':\n      self.data = [];\n      break;\n\n    case 'EDNS':\n      self.data = rdata;\n      break;\n\n    default:\n      throw new Error('Unknown record ' + self.kind() + ': ' + JSON.stringify(self));\n  }\n};\n\nDNSRecord.prototype.kind = function () {\n  return this.edns ? 'EDNS' : this.class + ' ' + this.type;\n};\n\nDNSRecord.prototype.toString = function () {\n  var self = this;\n  return [width(23, self.name), width(7, self.ttl || ''), width(7, self.class), width(7, self.type), self.type == 'MX' && self.data ? width(3, self.data[0]) + ' ' + self.data[1] : Buffer.isBuffer(self.data) ? self.data.toString('hex') : self.data || ''].join(' ');\n}; //\n// Utilities\n//\n\n\nfunction width(str_len, str) {\n  str = '' + str;\n\n  do {\n    var needed = str_len - str.length;\n    if (needed > 0) str = ' ' + str;\n  } while (needed > 0);\n\n  return str;\n}\n\nfunction inet_ntoa(buf) {\n  return buf[0] + '.' + buf[1] + '.' + buf[2] + '.' + buf[3];\n}\n\nfunction inet_ntoa6(buf) {\n  var result = [];\n\n  for (var i = 0; i < 16; i += 2) {\n    result.push(buf.slice(i, i + 2).toString('hex'));\n  }\n\n  return result.join(':');\n}","map":null,"metadata":{},"sourceType":"script"}