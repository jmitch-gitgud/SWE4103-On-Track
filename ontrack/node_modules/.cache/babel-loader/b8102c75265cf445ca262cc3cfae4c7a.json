{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"C:\\\\Users\\\\MicSc\\\\Documents\\\\SWE4103\\\\Project\\\\SWE4103-On-Track\\\\ontrack\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar utils = require('./utils');\n\nvar sasl = require('./sasl');\n\nvar pgPass = require('pgpass');\n\nvar TypeOverrides = require('./type-overrides');\n\nvar ConnectionParameters = require('./connection-parameters');\n\nvar Query = require('./query');\n\nvar defaults = require('./defaults');\n\nvar Connection = require('./connection');\n\nvar Client = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Client, _EventEmitter);\n\n  function Client(config) {\n    var _this;\n\n    _classCallCheck(this, Client);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Client).call(this));\n    _this.connectionParameters = new ConnectionParameters(config);\n    _this.user = _this.connectionParameters.user;\n    _this.database = _this.connectionParameters.database;\n    _this.port = _this.connectionParameters.port;\n    _this.host = _this.connectionParameters.host; // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n\n    Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: _this.connectionParameters.password\n    });\n    _this.replication = _this.connectionParameters.replication;\n    var c = config || {};\n    _this._Promise = c.Promise || global.Promise;\n    _this._types = new TypeOverrides(c.types);\n    _this._ending = false;\n    _this._connecting = false;\n    _this._connected = false;\n    _this._connectionError = false;\n    _this._queryable = true;\n    _this.connection = c.connection || new Connection({\n      stream: c.stream,\n      ssl: _this.connectionParameters.ssl,\n      keepAlive: c.keepAlive || false,\n      keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n      encoding: _this.connectionParameters.client_encoding || 'utf8'\n    });\n    _this.queryQueue = [];\n    _this.binary = c.binary || defaults.binary;\n    _this.processID = null;\n    _this.secretKey = null;\n    _this.ssl = _this.connectionParameters.ssl || false; // As with Password, make SSL->Key (the private key) non-enumerable.\n    // It won't show up in stack traces\n    // or if the client is console.logged\n\n    if (_this.ssl && _this.ssl.key) {\n      Object.defineProperty(_this.ssl, 'key', {\n        enumerable: false\n      });\n    }\n\n    _this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;\n    return _this;\n  }\n\n  _createClass(Client, [{\n    key: \"_errorAllQueries\",\n    value: function _errorAllQueries(err) {\n      var _this2 = this;\n\n      var enqueueError = function enqueueError(query) {\n        process.nextTick(function () {\n          query.handleError(err, _this2.connection);\n        });\n      };\n\n      if (this.activeQuery) {\n        enqueueError(this.activeQuery);\n        this.activeQuery = null;\n      }\n\n      this.queryQueue.forEach(enqueueError);\n      this.queryQueue.length = 0;\n    }\n  }, {\n    key: \"_connect\",\n    value: function _connect(callback) {\n      var _this3 = this;\n\n      var self = this;\n      var con = this.connection;\n      this._connectionCallback = callback;\n\n      if (this._connecting || this._connected) {\n        var err = new Error('Client has already been connected. You cannot reuse a client.');\n        process.nextTick(function () {\n          callback(err);\n        });\n        return;\n      }\n\n      this._connecting = true;\n      this.connectionTimeoutHandle;\n\n      if (this._connectionTimeoutMillis > 0) {\n        this.connectionTimeoutHandle = setTimeout(function () {\n          con._ending = true;\n          con.stream.destroy(new Error('timeout expired'));\n        }, this._connectionTimeoutMillis);\n      }\n\n      if (this.host && this.host.indexOf('/') === 0) {\n        con.connect(this.host + '/.s.PGSQL.' + this.port);\n      } else {\n        con.connect(this.port, this.host);\n      } // once connection is established send startup message\n\n\n      con.on('connect', function () {\n        if (self.ssl) {\n          con.requestSsl();\n        } else {\n          con.startup(self.getStartupConf());\n        }\n      });\n      con.on('sslconnect', function () {\n        con.startup(self.getStartupConf());\n      });\n\n      this._attachListeners(con);\n\n      con.once('end', function () {\n        var error = _this3._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly');\n        clearTimeout(_this3.connectionTimeoutHandle);\n\n        _this3._errorAllQueries(error);\n\n        if (!_this3._ending) {\n          // if the connection is ended without us calling .end()\n          // on this client then we have an unexpected disconnection\n          // treat this as an error unless we've already emitted an error\n          // during connection.\n          if (_this3._connecting && !_this3._connectionError) {\n            if (_this3._connectionCallback) {\n              _this3._connectionCallback(error);\n            } else {\n              _this3._handleErrorEvent(error);\n            }\n          } else if (!_this3._connectionError) {\n            _this3._handleErrorEvent(error);\n          }\n        }\n\n        process.nextTick(function () {\n          _this3.emit('end');\n        });\n      });\n    }\n  }, {\n    key: \"connect\",\n    value: function connect(callback) {\n      var _this4 = this;\n\n      if (callback) {\n        this._connect(callback);\n\n        return;\n      }\n\n      return new this._Promise(function (resolve, reject) {\n        _this4._connect(function (error) {\n          if (error) {\n            reject(error);\n          } else {\n            resolve();\n          }\n        });\n      });\n    }\n  }, {\n    key: \"_attachListeners\",\n    value: function _attachListeners(con) {\n      // password request handling\n      con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this)); // password request handling\n\n      con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this)); // password request handling (SASL)\n\n      con.on('authenticationSASL', this._handleAuthSASL.bind(this));\n      con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this));\n      con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this));\n      con.on('backendKeyData', this._handleBackendKeyData.bind(this));\n      con.on('error', this._handleErrorEvent.bind(this));\n      con.on('errorMessage', this._handleErrorMessage.bind(this));\n      con.on('readyForQuery', this._handleReadyForQuery.bind(this));\n      con.on('notice', this._handleNotice.bind(this));\n      con.on('rowDescription', this._handleRowDescription.bind(this));\n      con.on('dataRow', this._handleDataRow.bind(this));\n      con.on('portalSuspended', this._handlePortalSuspended.bind(this));\n      con.on('emptyQuery', this._handleEmptyQuery.bind(this));\n      con.on('commandComplete', this._handleCommandComplete.bind(this));\n      con.on('parseComplete', this._handleParseComplete.bind(this));\n      con.on('copyInResponse', this._handleCopyInResponse.bind(this));\n      con.on('copyData', this._handleCopyData.bind(this));\n      con.on('notification', this._handleNotification.bind(this));\n    } // TODO(bmc): deprecate pgpass \"built in\" integration since this.password can be a function\n    // it can be supplied by the user if required - this is a breaking change!\n\n  }, {\n    key: \"_checkPgPass\",\n    value: function _checkPgPass(cb) {\n      var _this5 = this;\n\n      var con = this.connection;\n\n      if (typeof this.password === 'function') {\n        this._Promise.resolve().then(function () {\n          return _this5.password();\n        }).then(function (pass) {\n          if (pass !== undefined) {\n            if (typeof pass !== 'string') {\n              con.emit('error', new TypeError('Password must be a string'));\n              return;\n            }\n\n            _this5.connectionParameters.password = _this5.password = pass;\n          } else {\n            _this5.connectionParameters.password = _this5.password = null;\n          }\n\n          cb();\n        }).catch(function (err) {\n          con.emit('error', err);\n        });\n      } else if (this.password !== null) {\n        cb();\n      } else {\n        pgPass(this.connectionParameters, function (pass) {\n          if (undefined !== pass) {\n            _this5.connectionParameters.password = _this5.password = pass;\n          }\n\n          cb();\n        });\n      }\n    }\n  }, {\n    key: \"_handleAuthCleartextPassword\",\n    value: function _handleAuthCleartextPassword(msg) {\n      var _this6 = this;\n\n      this._checkPgPass(function () {\n        _this6.connection.password(_this6.password);\n      });\n    }\n  }, {\n    key: \"_handleAuthMD5Password\",\n    value: function _handleAuthMD5Password(msg) {\n      var _this7 = this;\n\n      this._checkPgPass(function () {\n        var hashedPassword = utils.postgresMd5PasswordHash(_this7.user, _this7.password, msg.salt);\n\n        _this7.connection.password(hashedPassword);\n      });\n    }\n  }, {\n    key: \"_handleAuthSASL\",\n    value: function _handleAuthSASL(msg) {\n      var _this8 = this;\n\n      this._checkPgPass(function () {\n        _this8.saslSession = sasl.startSession(msg.mechanisms);\n\n        _this8.connection.sendSASLInitialResponseMessage(_this8.saslSession.mechanism, _this8.saslSession.response);\n      });\n    }\n  }, {\n    key: \"_handleAuthSASLContinue\",\n    value: function _handleAuthSASLContinue(msg) {\n      sasl.continueSession(this.saslSession, this.password, msg.data);\n      this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);\n    }\n  }, {\n    key: \"_handleAuthSASLFinal\",\n    value: function _handleAuthSASLFinal(msg) {\n      sasl.finalizeSession(this.saslSession, msg.data);\n      this.saslSession = null;\n    }\n  }, {\n    key: \"_handleBackendKeyData\",\n    value: function _handleBackendKeyData(msg) {\n      this.processID = msg.processID;\n      this.secretKey = msg.secretKey;\n    }\n  }, {\n    key: \"_handleReadyForQuery\",\n    value: function _handleReadyForQuery(msg) {\n      if (this._connecting) {\n        this._connecting = false;\n        this._connected = true;\n        clearTimeout(this.connectionTimeoutHandle); // process possible callback argument to Client#connect\n\n        if (this._connectionCallback) {\n          this._connectionCallback(null, this); // remove callback for proper error handling\n          // after the connect event\n\n\n          this._connectionCallback = null;\n        }\n\n        this.emit('connect');\n      }\n\n      var activeQuery = this.activeQuery;\n      this.activeQuery = null;\n      this.readyForQuery = true;\n\n      if (activeQuery) {\n        activeQuery.handleReadyForQuery(this.connection);\n      }\n\n      this._pulseQueryQueue();\n    } // if we receieve an error event or error message\n    // during the connection process we handle it here\n\n  }, {\n    key: \"_handleErrorWhileConnecting\",\n    value: function _handleErrorWhileConnecting(err) {\n      if (this._connectionError) {\n        // TODO(bmc): this is swallowing errors - we shouldn't do this\n        return;\n      }\n\n      this._connectionError = true;\n      clearTimeout(this.connectionTimeoutHandle);\n\n      if (this._connectionCallback) {\n        return this._connectionCallback(err);\n      }\n\n      this.emit('error', err);\n    } // if we're connected and we receive an error event from the connection\n    // this means the socket is dead - do a hard abort of all queries and emit\n    // the socket error on the client as well\n\n  }, {\n    key: \"_handleErrorEvent\",\n    value: function _handleErrorEvent(err) {\n      if (this._connecting) {\n        return this._handleErrorWhileConnecting(err);\n      }\n\n      this._queryable = false;\n\n      this._errorAllQueries(err);\n\n      this.emit('error', err);\n    } // handle error messages from the postgres backend\n\n  }, {\n    key: \"_handleErrorMessage\",\n    value: function _handleErrorMessage(msg) {\n      if (this._connecting) {\n        return this._handleErrorWhileConnecting(msg);\n      }\n\n      var activeQuery = this.activeQuery;\n\n      if (!activeQuery) {\n        this._handleErrorEvent(msg);\n\n        return;\n      }\n\n      this.activeQuery = null;\n      activeQuery.handleError(msg, this.connection);\n    }\n  }, {\n    key: \"_handleRowDescription\",\n    value: function _handleRowDescription(msg) {\n      // delegate rowDescription to active query\n      this.activeQuery.handleRowDescription(msg);\n    }\n  }, {\n    key: \"_handleDataRow\",\n    value: function _handleDataRow(msg) {\n      // delegate dataRow to active query\n      this.activeQuery.handleDataRow(msg);\n    }\n  }, {\n    key: \"_handlePortalSuspended\",\n    value: function _handlePortalSuspended(msg) {\n      // delegate portalSuspended to active query\n      this.activeQuery.handlePortalSuspended(this.connection);\n    }\n  }, {\n    key: \"_handleEmptyQuery\",\n    value: function _handleEmptyQuery(msg) {\n      // delegate emptyQuery to active query\n      this.activeQuery.handleEmptyQuery(this.connection);\n    }\n  }, {\n    key: \"_handleCommandComplete\",\n    value: function _handleCommandComplete(msg) {\n      // delegate commandComplete to active query\n      this.activeQuery.handleCommandComplete(msg, this.connection);\n    }\n  }, {\n    key: \"_handleParseComplete\",\n    value: function _handleParseComplete(msg) {\n      // if a prepared statement has a name and properly parses\n      // we track that its already been executed so we don't parse\n      // it again on the same client\n      if (this.activeQuery.name) {\n        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;\n      }\n    }\n  }, {\n    key: \"_handleCopyInResponse\",\n    value: function _handleCopyInResponse(msg) {\n      this.activeQuery.handleCopyInResponse(this.connection);\n    }\n  }, {\n    key: \"_handleCopyData\",\n    value: function _handleCopyData(msg) {\n      this.activeQuery.handleCopyData(msg, this.connection);\n    }\n  }, {\n    key: \"_handleNotification\",\n    value: function _handleNotification(msg) {\n      this.emit('notification', msg);\n    }\n  }, {\n    key: \"_handleNotice\",\n    value: function _handleNotice(msg) {\n      this.emit('notice', msg);\n    }\n  }, {\n    key: \"getStartupConf\",\n    value: function getStartupConf() {\n      var params = this.connectionParameters;\n      var data = {\n        user: params.user,\n        database: params.database\n      };\n      var appName = params.application_name || params.fallback_application_name;\n\n      if (appName) {\n        data.application_name = appName;\n      }\n\n      if (params.replication) {\n        data.replication = '' + params.replication;\n      }\n\n      if (params.statement_timeout) {\n        data.statement_timeout = String(parseInt(params.statement_timeout, 10));\n      }\n\n      if (params.lock_timeout) {\n        data.lock_timeout = String(parseInt(params.lock_timeout, 10));\n      }\n\n      if (params.idle_in_transaction_session_timeout) {\n        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));\n      }\n\n      if (params.options) {\n        data.options = params.options;\n      }\n\n      return data;\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(client, query) {\n      if (client.activeQuery === query) {\n        var con = this.connection;\n\n        if (this.host && this.host.indexOf('/') === 0) {\n          con.connect(this.host + '/.s.PGSQL.' + this.port);\n        } else {\n          con.connect(this.port, this.host);\n        } // once connection is established send cancel message\n\n\n        con.on('connect', function () {\n          con.cancel(client.processID, client.secretKey);\n        });\n      } else if (client.queryQueue.indexOf(query) !== -1) {\n        client.queryQueue.splice(client.queryQueue.indexOf(query), 1);\n      }\n    }\n  }, {\n    key: \"setTypeParser\",\n    value: function setTypeParser(oid, format, parseFn) {\n      return this._types.setTypeParser(oid, format, parseFn);\n    }\n  }, {\n    key: \"getTypeParser\",\n    value: function getTypeParser(oid, format) {\n      return this._types.getTypeParser(oid, format);\n    } // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n\n  }, {\n    key: \"escapeIdentifier\",\n    value: function escapeIdentifier(str) {\n      return '\"' + str.replace(/\"/g, '\"\"') + '\"';\n    } // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n\n  }, {\n    key: \"escapeLiteral\",\n    value: function escapeLiteral(str) {\n      var hasBackslash = false;\n      var escaped = \"'\";\n\n      for (var i = 0; i < str.length; i++) {\n        var c = str[i];\n\n        if (c === \"'\") {\n          escaped += c + c;\n        } else if (c === '\\\\') {\n          escaped += c + c;\n          hasBackslash = true;\n        } else {\n          escaped += c;\n        }\n      }\n\n      escaped += \"'\";\n\n      if (hasBackslash === true) {\n        escaped = ' E' + escaped;\n      }\n\n      return escaped;\n    }\n  }, {\n    key: \"_pulseQueryQueue\",\n    value: function _pulseQueryQueue() {\n      var _this9 = this;\n\n      if (this.readyForQuery === true) {\n        this.activeQuery = this.queryQueue.shift();\n\n        if (this.activeQuery) {\n          this.readyForQuery = false;\n          this.hasExecuted = true;\n          var queryError = this.activeQuery.submit(this.connection);\n\n          if (queryError) {\n            process.nextTick(function () {\n              _this9.activeQuery.handleError(queryError, _this9.connection);\n\n              _this9.readyForQuery = true;\n\n              _this9._pulseQueryQueue();\n            });\n          }\n        } else if (this.hasExecuted) {\n          this.activeQuery = null;\n          this.emit('drain');\n        }\n      }\n    }\n  }, {\n    key: \"query\",\n    value: function query(config, values, callback) {\n      var _this10 = this;\n\n      // can take in strings, config object or query object\n      var query;\n      var result;\n      var readTimeout;\n      var readTimeoutTimer;\n      var queryCallback;\n\n      if (config === null || config === undefined) {\n        throw new TypeError('Client was passed a null or undefined query');\n      } else if (typeof config.submit === 'function') {\n        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;\n        result = query = config;\n\n        if (typeof values === 'function') {\n          query.callback = query.callback || values;\n        }\n      } else {\n        readTimeout = this.connectionParameters.query_timeout;\n        query = new Query(config, values, callback);\n\n        if (!query.callback) {\n          result = new this._Promise(function (resolve, reject) {\n            query.callback = function (err, res) {\n              return err ? reject(err) : resolve(res);\n            };\n          });\n        }\n      }\n\n      if (readTimeout) {\n        queryCallback = query.callback;\n        readTimeoutTimer = setTimeout(function () {\n          var error = new Error('Query read timeout');\n          process.nextTick(function () {\n            query.handleError(error, _this10.connection);\n          });\n          queryCallback(error); // we already returned an error,\n          // just do nothing if query completes\n\n          query.callback = function () {}; // Remove from queue\n\n\n          var index = _this10.queryQueue.indexOf(query);\n\n          if (index > -1) {\n            _this10.queryQueue.splice(index, 1);\n          }\n\n          _this10._pulseQueryQueue();\n        }, readTimeout);\n\n        query.callback = function (err, res) {\n          clearTimeout(readTimeoutTimer);\n          queryCallback(err, res);\n        };\n      }\n\n      if (this.binary && !query.binary) {\n        query.binary = true;\n      }\n\n      if (query._result && !query._result._types) {\n        query._result._types = this._types;\n      }\n\n      if (!this._queryable) {\n        process.nextTick(function () {\n          query.handleError(new Error('Client has encountered a connection error and is not queryable'), _this10.connection);\n        });\n        return result;\n      }\n\n      if (this._ending) {\n        process.nextTick(function () {\n          query.handleError(new Error('Client was closed and is not queryable'), _this10.connection);\n        });\n        return result;\n      }\n\n      this.queryQueue.push(query);\n\n      this._pulseQueryQueue();\n\n      return result;\n    }\n  }, {\n    key: \"ref\",\n    value: function ref() {\n      this.connection.ref();\n    }\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      this.connection.unref();\n    }\n  }, {\n    key: \"end\",\n    value: function end(cb) {\n      var _this11 = this;\n\n      this._ending = true; // if we have never connected, then end is a noop, callback immediately\n\n      if (!this.connection._connecting) {\n        if (cb) {\n          cb();\n        } else {\n          return this._Promise.resolve();\n        }\n      }\n\n      if (this.activeQuery || !this._queryable) {\n        // if we have an active query we need to force a disconnect\n        // on the socket - otherwise a hung query could block end forever\n        this.connection.stream.destroy();\n      } else {\n        this.connection.end();\n      }\n\n      if (cb) {\n        this.connection.once('end', cb);\n      } else {\n        return new this._Promise(function (resolve) {\n          _this11.connection.once('end', resolve);\n        });\n      }\n    }\n  }]);\n\n  return Client;\n}(EventEmitter); // expose a Query constructor\n\n\nClient.Query = Query;\nmodule.exports = Client;","map":null,"metadata":{},"sourceType":"script"}