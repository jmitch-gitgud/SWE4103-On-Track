{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar Result = require('./result');\n\nvar utils = require('./utils');\n\nvar Query = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Query, _EventEmitter);\n\n  function Query(config, values, callback) {\n    var _this;\n\n    _classCallCheck(this, Query);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Query).call(this));\n    config = utils.normalizeQueryConfig(config, values, callback);\n    _this.text = config.text;\n    _this.values = config.values;\n    _this.rows = config.rows;\n    _this.types = config.types;\n    _this.name = config.name;\n    _this.binary = config.binary; // use unique portal name each time\n\n    _this.portal = config.portal || '';\n    _this.callback = config.callback;\n    _this._rowMode = config.rowMode;\n\n    if (process.domain && config.callback) {\n      _this.callback = process.domain.bind(config.callback);\n    }\n\n    _this._result = new Result(_this._rowMode, _this.types); // potential for multiple results\n\n    _this._results = _this._result;\n    _this.isPreparedStatement = false;\n    _this._canceledDueToError = false;\n    _this._promise = null;\n    return _this;\n  }\n\n  _createClass(Query, [{\n    key: \"requiresPreparation\",\n    value: function requiresPreparation() {\n      // named queries must always be prepared\n      if (this.name) {\n        return true;\n      } // always prepare if there are max number of rows expected per\n      // portal execution\n\n\n      if (this.rows) {\n        return true;\n      } // don't prepare empty text queries\n\n\n      if (!this.text) {\n        return false;\n      } // prepare if there are values\n\n\n      if (!this.values) {\n        return false;\n      }\n\n      return this.values.length > 0;\n    }\n  }, {\n    key: \"_checkForMultirow\",\n    value: function _checkForMultirow() {\n      // if we already have a result with a command property\n      // then we've already executed one query in a multi-statement simple query\n      // turn our results into an array of results\n      if (this._result.command) {\n        if (!Array.isArray(this._results)) {\n          this._results = [this._result];\n        }\n\n        this._result = new Result(this._rowMode, this.types);\n\n        this._results.push(this._result);\n      }\n    } // associates row metadata from the supplied\n    // message with this query object\n    // metadata used when parsing row results\n\n  }, {\n    key: \"handleRowDescription\",\n    value: function handleRowDescription(msg) {\n      this._checkForMultirow();\n\n      this._result.addFields(msg.fields);\n\n      this._accumulateRows = this.callback || !this.listeners('row').length;\n    }\n  }, {\n    key: \"handleDataRow\",\n    value: function handleDataRow(msg) {\n      var row;\n\n      if (this._canceledDueToError) {\n        return;\n      }\n\n      try {\n        row = this._result.parseRow(msg.fields);\n      } catch (err) {\n        this._canceledDueToError = err;\n        return;\n      }\n\n      this.emit('row', row, this._result);\n\n      if (this._accumulateRows) {\n        this._result.addRow(row);\n      }\n    }\n  }, {\n    key: \"handleCommandComplete\",\n    value: function handleCommandComplete(msg, connection) {\n      this._checkForMultirow();\n\n      this._result.addCommandComplete(msg); // need to sync after each command complete of a prepared statement\n      // if we were using a row count which results in multiple calls to _getRows\n\n\n      if (this.rows) {\n        connection.sync();\n      }\n    } // if a named prepared statement is created with empty query text\n    // the backend will send an emptyQuery message but *not* a command complete message\n    // since we pipeline sync immediately after execute we don't need to do anything here\n    // unless we have rows specified, in which case we did not pipeline the intial sync call\n\n  }, {\n    key: \"handleEmptyQuery\",\n    value: function handleEmptyQuery(connection) {\n      if (this.rows) {\n        connection.sync();\n      }\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(err, connection) {\n      // need to sync after error during a prepared statement\n      if (this._canceledDueToError) {\n        err = this._canceledDueToError;\n        this._canceledDueToError = false;\n      } // if callback supplied do not emit error event as uncaught error\n      // events will bubble up to node process\n\n\n      if (this.callback) {\n        return this.callback(err);\n      }\n\n      this.emit('error', err);\n    }\n  }, {\n    key: \"handleReadyForQuery\",\n    value: function handleReadyForQuery(con) {\n      if (this._canceledDueToError) {\n        return this.handleError(this._canceledDueToError, con);\n      }\n\n      if (this.callback) {\n        try {\n          this.callback(null, this._results);\n        } catch (err) {\n          process.nextTick(function () {\n            throw err;\n          });\n        }\n      }\n\n      this.emit('end', this._results);\n    }\n  }, {\n    key: \"submit\",\n    value: function submit(connection) {\n      if (typeof this.text !== 'string' && typeof this.name !== 'string') {\n        return new Error('A query must have either text or a name. Supplying neither is unsupported.');\n      }\n\n      var previous = connection.parsedStatements[this.name];\n\n      if (this.text && previous && this.text !== previous) {\n        return new Error(\"Prepared statements must be unique - '\".concat(this.name, \"' was used for a different statement\"));\n      }\n\n      if (this.values && !Array.isArray(this.values)) {\n        return new Error('Query values must be an array');\n      }\n\n      if (this.requiresPreparation()) {\n        this.prepare(connection);\n      } else {\n        connection.query(this.text);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"hasBeenParsed\",\n    value: function hasBeenParsed(connection) {\n      return this.name && connection.parsedStatements[this.name];\n    }\n  }, {\n    key: \"handlePortalSuspended\",\n    value: function handlePortalSuspended(connection) {\n      this._getRows(connection, this.rows);\n    }\n  }, {\n    key: \"_getRows\",\n    value: function _getRows(connection, rows) {\n      connection.execute({\n        portal: this.portal,\n        rows: rows\n      }); // if we're not reading pages of rows send the sync command\n      // to indicate the pipeline is finished\n\n      if (!rows) {\n        connection.sync();\n      } else {\n        // otherwise flush the call out to read more rows\n        connection.flush();\n      }\n    } // http://developer.postgresql.org/pgdocs/postgres/protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(connection) {\n      // prepared statements need sync to be called after each command\n      // complete or when an error is encountered\n      this.isPreparedStatement = true; // TODO refactor this poor encapsulation\n\n      if (!this.hasBeenParsed(connection)) {\n        connection.parse({\n          text: this.text,\n          name: this.name,\n          types: this.types\n        });\n      } // because we're mapping user supplied values to\n      // postgres wire protocol compatible values it could\n      // throw an exception, so try/catch this section\n\n\n      try {\n        connection.bind({\n          portal: this.portal,\n          statement: this.name,\n          values: this.values,\n          binary: this.binary,\n          valueMapper: utils.prepareValue\n        });\n      } catch (err) {\n        this.handleError(err, connection);\n        return;\n      }\n\n      connection.describe({\n        type: 'P',\n        name: this.portal || ''\n      });\n\n      this._getRows(connection, this.rows);\n    }\n  }, {\n    key: \"handleCopyInResponse\",\n    value: function handleCopyInResponse(connection) {\n      connection.sendCopyFail('No source stream defined');\n    } // eslint-disable-next-line no-unused-vars\n\n  }, {\n    key: \"handleCopyData\",\n    value: function handleCopyData(msg, connection) {// noop\n    }\n  }]);\n\n  return Query;\n}(EventEmitter);\n\nmodule.exports = Query;","map":null,"metadata":{},"sourceType":"script"}