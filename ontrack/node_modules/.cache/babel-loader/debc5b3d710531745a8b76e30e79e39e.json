{"ast":null,"code":"// Copyright 2012 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n'use strict';\n\nvar net = require('net'),\n    util = require('util'),\n    EventEmitter = require('events').EventEmitter,\n    Packet = require('./packet'),\n    consts = require('native-dns-packet').consts,\n    UDPSocket = require('./utils').UDPSocket,\n    TCPSocket = require('./utils').TCPSocket;\n\nvar debug = function debug() {//var args = Array.prototype.slice.call(arguments);\n  //console.log.apply(this, ['pending', Date.now().toString()].concat(args));\n};\n\nvar SocketQueue = function SocketQueue(socket, server) {\n  this._active = {};\n  this._active_count = 0;\n  this._pending = [];\n  debug('created', server);\n  this._server = server;\n  this._socket = socket;\n\n  this._socket.on('ready', this._onlisten.bind(this));\n\n  this._socket.on('message', this._onmessage.bind(this));\n\n  this._socket.on('close', this._onclose.bind(this));\n\n  this._socket.bind(server);\n\n  this._refd = true;\n};\n\nutil.inherits(SocketQueue, EventEmitter);\n\nSocketQueue.prototype.send = function (request) {\n  debug('added', request.question);\n\n  this._pending.push(request);\n\n  this._fill();\n};\n\nSocketQueue.prototype.remove = function (request) {\n  var req = this._active[request.id];\n\n  var idx = this._pending.indexOf(request);\n\n  if (req) {\n    delete this._active[request.id];\n    this._active_count -= 1;\n\n    this._fill();\n  }\n\n  if (idx > -1) this._pending.splice(idx, 1);\n\n  this._unref();\n};\n\nSocketQueue.prototype.close = function () {\n  debug('closing', this._server);\n\n  this._socket.close();\n\n  this._socket = undefined;\n  this.emit('close');\n};\n\nSocketQueue.prototype._fill = function () {\n  debug('pre fill, active:', this._active_count, 'pending:', this._pending.length);\n\n  while (this._listening && this._pending.length && this._active_count < 100) {\n    this._dequeue();\n  }\n\n  debug('post fill, active:', this._active_count, 'pending:', this._pending.length);\n};\n\nvar random_integer = function random_integer() {\n  return Math.floor(Math.random() * 50000 + 1);\n};\n\nSocketQueue.prototype._dequeue = function () {\n  var req = this._pending.pop();\n\n  var id, packet, dnssocket;\n\n  if (req) {\n    id = random_integer();\n\n    while (this._active[id]) {\n      id = random_integer();\n    }\n\n    debug('sending', req.question, id);\n    req.id = id;\n    this._active[id] = req;\n    this._active_count += 1;\n\n    try {\n      packet = new Packet(this._socket.remote(req.server));\n      packet.header.id = id;\n      packet.header.rd = 1;\n\n      if (req.try_edns) {\n        packet.edns_version = 0; //TODO when we support dnssec\n        //packet.do = 1\n      }\n\n      packet.question.push(req.question);\n      packet.send();\n\n      this._ref();\n    } catch (e) {\n      req.error(e);\n    }\n  }\n};\n\nSocketQueue.prototype._onmessage = function (msg, remote) {\n  var req;\n  debug('got a message', this._server);\n\n  try {\n    var packet = Packet.parse(msg, remote);\n    req = this._active[packet.header.id];\n    debug('associated message', packet.header.id);\n  } catch (e) {\n    debug('error parsing packet', e);\n  }\n\n  if (req) {\n    delete this._active[packet.header.id];\n    this._active_count -= 1;\n    req.handle(null, packet);\n\n    this._fill();\n  }\n\n  this._unref();\n};\n\nSocketQueue.prototype._unref = function () {\n  var self = this;\n  this._refd = false;\n\n  if (this._active_count <= 0) {\n    if (this._socket.unref) {\n      debug('unrefd socket');\n\n      this._socket.unref();\n    } else if (!this._timer) {\n      this._timer = setTimeout(function () {\n        self.close();\n      }, 300);\n    }\n  }\n};\n\nSocketQueue.prototype._ref = function () {\n  this._refd = true;\n\n  if (this._socket.ref) {\n    debug('refd socket');\n\n    this._socket.ref();\n  } else if (this._timer) {\n    clearTimeout(this._timer);\n    this._timer = null;\n  }\n};\n\nSocketQueue.prototype._onlisten = function () {\n  this._unref();\n\n  this._listening = true;\n\n  this._fill();\n};\n\nSocketQueue.prototype._onclose = function () {\n  var req,\n      err,\n      self = this;\n  debug('socket closed', this);\n  this._listening = false;\n  err = new Error('getHostByName ' + consts.TIMEOUT);\n  err.errno = consts.TIMEOUT;\n\n  while (this._pending.length) {\n    req = this._pending.pop();\n    req.error(err);\n  }\n\n  Object.keys(this._active).forEach(function (key) {\n    var req = self._active[key];\n    req.error(err);\n    delete self._active[key];\n    self._active_count -= 1;\n  });\n};\n\nvar serverHash = function serverHash(server) {\n  if (server.type === 'tcp') return server.address + ':' + server.port;else return 'udp' + net.isIP(server.address);\n};\n\nvar _sockets = {};\n\nexports.send = function (request) {\n  var hash = serverHash(request.server);\n  var socket = _sockets[hash];\n\n  if (!socket) {\n    switch (hash) {\n      case 'udp4':\n      case 'udp6':\n        socket = new SocketQueue(new UDPSocket(), hash);\n        break;\n\n      default:\n        socket = new SocketQueue(new TCPSocket(), request.server);\n        break;\n    }\n\n    socket.on('close', function () {\n      delete _sockets[hash];\n    });\n    _sockets[hash] = socket;\n  }\n\n  socket.send(request);\n};\n\nexports.remove = function (request) {\n  var hash = serverHash(request.server);\n  var socket = _sockets[hash];\n\n  if (socket) {\n    socket.remove(request);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}