{"ast":null,"code":"// Copyright 2012 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\nvar util = require('util');\n\nvar VError = require('verror');\n\nvar BufferCursor = module.exports = function (buff, noAssert) {\n  if (!(this instanceof BufferCursor)) return new BufferCursor(buff, noAssert);\n  this._pos = 0;\n  this._noAssert = noAssert;\n  if (this._noAssert === undefined) this._noAssert = true;\n  this.buffer = buff;\n  this.length = buff.length;\n};\n\nvar BCO = BufferCursor.BufferCursorOverflow = function (length, pos, size) {\n  this.kind = 'BufferCursorOverflow';\n  this.length = length;\n  this.position = pos;\n  this.size = size;\n  VError.call(this, 'BufferCursorOverflow: length %d, position %d, size %d', length, pos, size);\n};\n\nutil.inherits(BCO, VError);\n\nBufferCursor.prototype._move = function (step) {\n  this._checkWrite(step);\n\n  this._pos += step;\n};\n\nBufferCursor.prototype._checkWrite = function (size) {\n  var shouldThrow = false;\n  var length = this.length;\n  var pos = this._pos;\n  if (size > length) shouldThrow = true;\n  if (length - pos < size) shouldThrow = true;\n\n  if (shouldThrow) {\n    var bco = new BCO(length, pos, size);\n    throw bco;\n  }\n};\n\nBufferCursor.prototype.seek = function (pos) {\n  if (pos < 0) throw new VError(new RangeError('Cannot seek before start of buffer'), 'Negative seek values not allowed: %d', pos);\n  if (pos > this.length) throw new VError(new RangeError('Trying to seek beyond buffer'), 'Requested %d position is beyond length %d', pos, this.length);\n  this._pos = pos;\n  return this;\n};\n\nBufferCursor.prototype.eof = function () {\n  return this._pos == this.length;\n};\n\nBufferCursor.prototype.toByteArray = function (method) {\n  var arr = [],\n      i,\n      part,\n      count;\n\n  if (!method) {\n    method = 'readUInt8';\n    part = 1;\n  }\n\n  if (method.indexOf('16') > 0) part = 2;else if (method.indexOf('32') > 0) part = 4;\n  count = this.length / part;\n\n  for (i = 0; i < this.buffer.length; i += part) {\n    arr.push(this.buffer[method](i));\n  }\n\n  return arr;\n};\n\nBufferCursor.prototype.tell = function () {\n  return this._pos;\n};\n\nBufferCursor.prototype.slice = function (length) {\n  var end, b;\n\n  if (length === undefined) {\n    end = this.length;\n  } else {\n    end = this._pos + length;\n  }\n\n  b = new BufferCursor(this.buffer.slice(this._pos, end));\n  this.seek(end);\n  return b;\n};\n\nBufferCursor.prototype.toString = function (encoding, length) {\n  var end, ret;\n\n  if (length === undefined) {\n    end = this.length;\n  } else {\n    end = this._pos + length;\n  }\n\n  if (!encoding) {\n    encoding = 'utf8';\n  }\n\n  ret = this.buffer.toString(encoding, this._pos, end);\n  this.seek(end);\n  return ret;\n}; // This method doesn't need to _checkWrite because Buffer implicitly truncates\n// to the length of the buffer, it's the only method in Node core that behaves\n// this way by default\n\n\nBufferCursor.prototype.write = function (value, length, encoding) {\n  var end, ret;\n  ret = this.buffer.write(value, this._pos, length, encoding);\n\n  this._move(ret);\n\n  return this;\n};\n\nBufferCursor.prototype.fill = function (value, length) {\n  var end;\n\n  if (length === undefined) {\n    end = this.length;\n  } else {\n    end = this._pos + length;\n  }\n\n  this._checkWrite(end - this._pos);\n\n  this.buffer.fill(value, this._pos, end);\n  this.seek(end);\n  return this;\n}; // This prototype is not entirely like the upstream Buffer.copy, instead it\n// is the target buffer, and accepts the source buffer -- since the target\n// buffer knows its starting position\n\n\nBufferCursor.prototype.copy = function copy(source, sourceStart, sourceEnd) {\n  var sBC = source instanceof BufferCursor;\n  if (isNaN(sourceEnd)) sourceEnd = source.length;\n\n  if (isNaN(sourceStart)) {\n    if (sBC) sourceStart = source._pos;else sourceStart = 0;\n  }\n\n  var length = sourceEnd - sourceStart;\n\n  this._checkWrite(length);\n\n  var buf = sBC ? source.buffer : source;\n  buf.copy(this.buffer, this._pos, sourceStart, sourceEnd);\n\n  this._move(length);\n\n  return this;\n};\n\nBufferCursor.prototype.readUInt8 = function () {\n  var ret = this.buffer.readUInt8(this._pos, this._noAssert);\n\n  this._move(1);\n\n  return ret;\n};\n\nBufferCursor.prototype.readInt8 = function () {\n  var ret = this.buffer.readInt8(this._pos, this._noAssert);\n\n  this._move(1);\n\n  return ret;\n};\n\nBufferCursor.prototype.readInt16BE = function () {\n  var ret = this.buffer.readInt16BE(this._pos, this._noAssert);\n\n  this._move(2);\n\n  return ret;\n};\n\nBufferCursor.prototype.readInt16LE = function () {\n  var ret = this.buffer.readInt16LE(this._pos, this._noAssert);\n\n  this._move(2);\n\n  return ret;\n};\n\nBufferCursor.prototype.readUInt16BE = function () {\n  var ret = this.buffer.readUInt16BE(this._pos, this._noAssert);\n\n  this._move(2);\n\n  return ret;\n};\n\nBufferCursor.prototype.readUInt16LE = function () {\n  var ret = this.buffer.readUInt16LE(this._pos, this._noAssert);\n\n  this._move(2);\n\n  return ret;\n};\n\nBufferCursor.prototype.readUInt32LE = function () {\n  var ret = this.buffer.readUInt32LE(this._pos, this._noAssert);\n\n  this._move(4);\n\n  return ret;\n};\n\nBufferCursor.prototype.readUInt32BE = function () {\n  var ret = this.buffer.readUInt32BE(this._pos, this._noAssert);\n\n  this._move(4);\n\n  return ret;\n};\n\nBufferCursor.prototype.readInt32LE = function () {\n  var ret = this.buffer.readInt32LE(this._pos, this._noAssert);\n\n  this._move(4);\n\n  return ret;\n};\n\nBufferCursor.prototype.readInt32BE = function () {\n  var ret = this.buffer.readInt32BE(this._pos, this._noAssert);\n\n  this._move(4);\n\n  return ret;\n};\n\nBufferCursor.prototype.readFloatBE = function () {\n  var ret = this.buffer.readFloatBE(this._pos, this._noAssert);\n\n  this._move(4);\n\n  return ret;\n};\n\nBufferCursor.prototype.readFloatLE = function () {\n  var ret = this.buffer.readFloatLE(this._pos, this._noAssert);\n\n  this._move(4);\n\n  return ret;\n};\n\nBufferCursor.prototype.readDoubleBE = function () {\n  var ret = this.buffer.readDoubleBE(this._pos, this._noAssert);\n\n  this._move(8);\n\n  return ret;\n};\n\nBufferCursor.prototype.readDoubleLE = function () {\n  var ret = this.buffer.readDoubleLE(this._pos, this._noAssert);\n\n  this._move(8);\n\n  return ret;\n};\n\nBufferCursor.prototype.writeUInt8 = function (value) {\n  this._checkWrite(1);\n\n  this.buffer.writeUInt8(value, this._pos, this._noAssert);\n\n  this._move(1);\n\n  return this;\n};\n\nBufferCursor.prototype.writeInt8 = function (value) {\n  this._checkWrite(1);\n\n  this.buffer.writeInt8(value, this._pos, this._noAssert);\n\n  this._move(1);\n\n  return this;\n};\n\nBufferCursor.prototype.writeUInt16BE = function (value) {\n  this._checkWrite(2);\n\n  this.buffer.writeUInt16BE(value, this._pos, this._noAssert);\n\n  this._move(2);\n\n  return this;\n};\n\nBufferCursor.prototype.writeUInt16LE = function (value) {\n  this._checkWrite(2);\n\n  this.buffer.writeUInt16LE(value, this._pos, this._noAssert);\n\n  this._move(2);\n\n  return this;\n};\n\nBufferCursor.prototype.writeInt16BE = function (value) {\n  this._checkWrite(2);\n\n  this.buffer.writeInt16BE(value, this._pos, this._noAssert);\n\n  this._move(2);\n\n  return this;\n};\n\nBufferCursor.prototype.writeInt16LE = function (value) {\n  this._checkWrite(2);\n\n  this.buffer.writeInt16LE(value, this._pos, this._noAssert);\n\n  this._move(2);\n\n  return this;\n};\n\nBufferCursor.prototype.writeUInt32BE = function (value) {\n  this._checkWrite(4);\n\n  this.buffer.writeUInt32BE(value, this._pos, this._noAssert);\n\n  this._move(4);\n\n  return this;\n};\n\nBufferCursor.prototype.writeUInt32LE = function (value) {\n  this._checkWrite(4);\n\n  this.buffer.writeUInt32LE(value, this._pos, this._noAssert);\n\n  this._move(4);\n\n  return this;\n};\n\nBufferCursor.prototype.writeInt32BE = function (value) {\n  this._checkWrite(4);\n\n  this.buffer.writeInt32BE(value, this._pos, this._noAssert);\n\n  this._move(4);\n\n  return this;\n};\n\nBufferCursor.prototype.writeInt32LE = function (value) {\n  this._checkWrite(4);\n\n  this.buffer.writeInt32LE(value, this._pos, this._noAssert);\n\n  this._move(4);\n\n  return this;\n};\n\nBufferCursor.prototype.writeFloatBE = function (value) {\n  this._checkWrite(4);\n\n  this.buffer.writeFloatBE(value, this._pos, this._noAssert);\n\n  this._move(4);\n\n  return this;\n};\n\nBufferCursor.prototype.writeFloatLE = function (value) {\n  this._checkWrite(4);\n\n  this.buffer.writeFloatLE(value, this._pos, this._noAssert);\n\n  this._move(4);\n\n  return this;\n};\n\nBufferCursor.prototype.writeDoubleBE = function (value) {\n  this._checkWrite(8);\n\n  this.buffer.writeDoubleBE(value, this._pos, this._noAssert);\n\n  this._move(8);\n\n  return this;\n};\n\nBufferCursor.prototype.writeDoubleLE = function (value) {\n  this._checkWrite(8);\n\n  this.buffer.writeDoubleLE(value, this._pos, this._noAssert);\n\n  this._move(8);\n\n  return this;\n};","map":null,"metadata":{},"sourceType":"script"}