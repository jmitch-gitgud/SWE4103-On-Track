{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/jordanm/Documents/GitHub/SWE4103-Team-Project/ontrack/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar types = require('pg-types');\n\nvar matchRegexp = /^([A-Za-z]+)(?: (\\d+))?(?: (\\d+))?/; // result object returned from query\n// in the 'end' event and also\n// passed as second argument to provided callback\n\nvar Result = /*#__PURE__*/function () {\n  function Result(rowMode, types) {\n    _classCallCheck(this, Result);\n\n    this.command = null;\n    this.rowCount = null;\n    this.oid = null;\n    this.rows = [];\n    this.fields = [];\n    this._parsers = undefined;\n    this._types = types;\n    this.RowCtor = null;\n    this.rowAsArray = rowMode === 'array';\n\n    if (this.rowAsArray) {\n      this.parseRow = this._parseRowAsArray;\n    }\n  } // adds a command complete message\n\n\n  _createClass(Result, [{\n    key: \"addCommandComplete\",\n    value: function addCommandComplete(msg) {\n      var match;\n\n      if (msg.text) {\n        // pure javascript\n        match = matchRegexp.exec(msg.text);\n      } else {\n        // native bindings\n        match = matchRegexp.exec(msg.command);\n      }\n\n      if (match) {\n        this.command = match[1];\n\n        if (match[3]) {\n          // COMMMAND OID ROWS\n          this.oid = parseInt(match[2], 10);\n          this.rowCount = parseInt(match[3], 10);\n        } else if (match[2]) {\n          // COMMAND ROWS\n          this.rowCount = parseInt(match[2], 10);\n        }\n      }\n    }\n  }, {\n    key: \"_parseRowAsArray\",\n    value: function _parseRowAsArray(rowData) {\n      var row = new Array(rowData.length);\n\n      for (var i = 0, len = rowData.length; i < len; i++) {\n        var rawValue = rowData[i];\n\n        if (rawValue !== null) {\n          row[i] = this._parsers[i](rawValue);\n        } else {\n          row[i] = null;\n        }\n      }\n\n      return row;\n    }\n  }, {\n    key: \"parseRow\",\n    value: function parseRow(rowData) {\n      var row = {};\n\n      for (var i = 0, len = rowData.length; i < len; i++) {\n        var rawValue = rowData[i];\n        var field = this.fields[i].name;\n\n        if (rawValue !== null) {\n          row[field] = this._parsers[i](rawValue);\n        } else {\n          row[field] = null;\n        }\n      }\n\n      return row;\n    }\n  }, {\n    key: \"addRow\",\n    value: function addRow(row) {\n      this.rows.push(row);\n    }\n  }, {\n    key: \"addFields\",\n    value: function addFields(fieldDescriptions) {\n      // clears field definitions\n      // multiple query statements in 1 action can result in multiple sets\n      // of rowDescriptions...eg: 'select NOW(); select 1::int;'\n      // you need to reset the fields\n      this.fields = fieldDescriptions;\n\n      if (this.fields.length) {\n        this._parsers = new Array(fieldDescriptions.length);\n      }\n\n      for (var i = 0; i < fieldDescriptions.length; i++) {\n        var desc = fieldDescriptions[i];\n\n        if (this._types) {\n          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || 'text');\n        } else {\n          this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || 'text');\n        }\n      }\n    }\n  }]);\n\n  return Result;\n}();\n\nmodule.exports = Result;","map":null,"metadata":{},"sourceType":"script"}