{"ast":null,"code":"'use strict';\n\nvar crypto = require('crypto');\n\nfunction startSession(mechanisms) {\n  if (mechanisms.indexOf('SCRAM-SHA-256') === -1) {\n    throw new Error('SASL: Only mechanism SCRAM-SHA-256 is currently supported');\n  }\n\n  var clientNonce = crypto.randomBytes(18).toString('base64');\n  return {\n    mechanism: 'SCRAM-SHA-256',\n    clientNonce: clientNonce,\n    response: 'n,,n=*,r=' + clientNonce,\n    message: 'SASLInitialResponse'\n  };\n}\n\nfunction continueSession(session, password, serverData) {\n  if (session.message !== 'SASLInitialResponse') {\n    throw new Error('SASL: Last message was not SASLInitialResponse');\n  }\n\n  if (typeof password !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string');\n  }\n\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string');\n  }\n\n  var sv = parseServerFirstMessage(serverData);\n\n  if (!sv.nonce.startsWith(session.clientNonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce');\n  } else if (sv.nonce.length === session.clientNonce.length) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short');\n  }\n\n  var saltBytes = Buffer.from(sv.salt, 'base64');\n  var saltedPassword = Hi(password, saltBytes, sv.iteration);\n  var clientKey = hmacSha256(saltedPassword, 'Client Key');\n  var storedKey = sha256(clientKey);\n  var clientFirstMessageBare = 'n=*,r=' + session.clientNonce;\n  var serverFirstMessage = 'r=' + sv.nonce + ',s=' + sv.salt + ',i=' + sv.iteration;\n  var clientFinalMessageWithoutProof = 'c=biws,r=' + sv.nonce;\n  var authMessage = clientFirstMessageBare + ',' + serverFirstMessage + ',' + clientFinalMessageWithoutProof;\n  var clientSignature = hmacSha256(storedKey, authMessage);\n  var clientProofBytes = xorBuffers(clientKey, clientSignature);\n  var clientProof = clientProofBytes.toString('base64');\n  var serverKey = hmacSha256(saltedPassword, 'Server Key');\n  var serverSignatureBytes = hmacSha256(serverKey, authMessage);\n  session.message = 'SASLResponse';\n  session.serverSignature = serverSignatureBytes.toString('base64');\n  session.response = clientFinalMessageWithoutProof + ',p=' + clientProof;\n}\n\nfunction finalizeSession(session, serverData) {\n  if (session.message !== 'SASLResponse') {\n    throw new Error('SASL: Last message was not SASLResponse');\n  }\n\n  if (typeof serverData !== 'string') {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string');\n  }\n\n  var _parseServerFinalMess = parseServerFinalMessage(serverData),\n      serverSignature = _parseServerFinalMess.serverSignature;\n\n  if (serverSignature !== session.serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match');\n  }\n}\n/**\n * printable       = %x21-2B / %x2D-7E\n *                   ;; Printable ASCII except \",\".\n *                   ;; Note that any \"printable\" is also\n *                   ;; a valid \"value\".\n */\n\n\nfunction isPrintableChars(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: text must be a string');\n  }\n\n  return text.split('').map(function (_, i) {\n    return text.charCodeAt(i);\n  }).every(function (c) {\n    return c >= 0x21 && c <= 0x2b || c >= 0x2d && c <= 0x7e;\n  });\n}\n/**\n * base64-char     = ALPHA / DIGIT / \"/\" / \"+\"\n *\n * base64-4        = 4base64-char\n *\n * base64-3        = 3base64-char \"=\"\n *\n * base64-2        = 2base64-char \"==\"\n *\n * base64          = *base64-4 [base64-3 / base64-2]\n */\n\n\nfunction isBase64(text) {\n  return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);\n}\n\nfunction parseAttributePairs(text) {\n  if (typeof text !== 'string') {\n    throw new TypeError('SASL: attribute pairs text must be a string');\n  }\n\n  return new Map(text.split(',').map(function (attrValue) {\n    if (!/^.=/.test(attrValue)) {\n      throw new Error('SASL: Invalid attribute pair entry');\n    }\n\n    var name = attrValue[0];\n    var value = attrValue.substring(2);\n    return [name, value];\n  }));\n}\n\nfunction parseServerFirstMessage(data) {\n  var attrPairs = parseAttributePairs(data);\n  var nonce = attrPairs.get('r');\n\n  if (!nonce) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing');\n  } else if (!isPrintableChars(nonce)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters');\n  }\n\n  var salt = attrPairs.get('s');\n\n  if (!salt) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing');\n  } else if (!isBase64(salt)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64');\n  }\n\n  var iterationText = attrPairs.get('i');\n\n  if (!iterationText) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing');\n  } else if (!/^[1-9][0-9]*$/.test(iterationText)) {\n    throw new Error('SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count');\n  }\n\n  var iteration = parseInt(iterationText, 10);\n  return {\n    nonce: nonce,\n    salt: salt,\n    iteration: iteration\n  };\n}\n\nfunction parseServerFinalMessage(serverData) {\n  var attrPairs = parseAttributePairs(serverData);\n  var serverSignature = attrPairs.get('v');\n\n  if (!serverSignature) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing');\n  } else if (!isBase64(serverSignature)) {\n    throw new Error('SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64');\n  }\n\n  return {\n    serverSignature: serverSignature\n  };\n}\n\nfunction xorBuffers(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    throw new TypeError('first argument must be a Buffer');\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    throw new TypeError('second argument must be a Buffer');\n  }\n\n  if (a.length !== b.length) {\n    throw new Error('Buffer lengths must match');\n  }\n\n  if (a.length === 0) {\n    throw new Error('Buffers cannot be empty');\n  }\n\n  return Buffer.from(a.map(function (_, i) {\n    return a[i] ^ b[i];\n  }));\n}\n\nfunction sha256(text) {\n  return crypto.createHash('sha256').update(text).digest();\n}\n\nfunction hmacSha256(key, msg) {\n  return crypto.createHmac('sha256', key).update(msg).digest();\n}\n\nfunction Hi(password, saltBytes, iterations) {\n  var ui1 = hmacSha256(password, Buffer.concat([saltBytes, Buffer.from([0, 0, 0, 1])]));\n  var ui = ui1;\n\n  for (var i = 0; i < iterations - 1; i++) {\n    ui1 = hmacSha256(password, ui1);\n    ui = xorBuffers(ui, ui1);\n  }\n\n  return ui;\n}\n\nmodule.exports = {\n  startSession: startSession,\n  continueSession: continueSession,\n  finalizeSession: finalizeSession\n};","map":null,"metadata":{},"sourceType":"script"}