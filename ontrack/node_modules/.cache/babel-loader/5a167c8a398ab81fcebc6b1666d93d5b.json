{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serialize = void 0;\n\nvar buffer_writer_1 = require(\"./buffer-writer\");\n\nvar writer = new buffer_writer_1.Writer();\n\nvar startup = function startup(opts) {\n  // protocol version\n  writer.addInt16(3).addInt16(0);\n\n  for (var _i = 0, _Object$keys = Object.keys(opts); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    writer.addCString(key).addCString(opts[key]);\n  }\n\n  writer.addCString('client_encoding').addCString('UTF8');\n  var bodyBuffer = writer.addCString('').flush(); // this message is sent without a code\n\n  var length = bodyBuffer.length + 4;\n  return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();\n};\n\nvar requestSsl = function requestSsl() {\n  var response = Buffer.allocUnsafe(8);\n  response.writeInt32BE(8, 0);\n  response.writeInt32BE(80877103, 4);\n  return response;\n};\n\nvar password = function password(_password) {\n  return writer.addCString(_password).flush(112\n  /* startup */\n  );\n};\n\nvar sendSASLInitialResponseMessage = function sendSASLInitialResponseMessage(mechanism, initialResponse) {\n  // 0x70 = 'p'\n  writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);\n  return writer.flush(112\n  /* startup */\n  );\n};\n\nvar sendSCRAMClientFinalMessage = function sendSCRAMClientFinalMessage(additionalData) {\n  return writer.addString(additionalData).flush(112\n  /* startup */\n  );\n};\n\nvar query = function query(text) {\n  return writer.addCString(text).flush(81\n  /* query */\n  );\n};\n\nvar emptyArray = [];\n\nvar parse = function parse(query) {\n  // expect something like this:\n  // { name: 'queryName',\n  //   text: 'select * from blah',\n  //   types: ['int8', 'bool'] }\n  // normalize missing query names to allow for null\n  var name = query.name || '';\n\n  if (name.length > 63) {\n    /* eslint-disable no-console */\n    console.error('Warning! Postgres only supports 63 characters for query names.');\n    console.error('You supplied %s (%s)', name, name.length);\n    console.error('This can cause conflicts and silent errors executing queries');\n    /* eslint-enable no-console */\n  }\n\n  var types = query.types || emptyArray;\n  var len = types.length;\n  var buffer = writer.addCString(name) // name of query\n  .addCString(query.text) // actual query text\n  .addInt16(len);\n\n  for (var i = 0; i < len; i++) {\n    buffer.addInt32(types[i]);\n  }\n\n  return writer.flush(80\n  /* parse */\n  );\n};\n\nvar paramWriter = new buffer_writer_1.Writer();\n\nvar writeValues = function writeValues(values, valueMapper) {\n  for (var i = 0; i < values.length; i++) {\n    var mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];\n\n    if (mappedVal == null) {\n      // add the param type (string) to the writer\n      writer.addInt16(0\n      /* STRING */\n      ); // write -1 to the param writer to indicate null\n\n      paramWriter.addInt32(-1);\n    } else if (mappedVal instanceof Buffer) {\n      // add the param type (binary) to the writer\n      writer.addInt16(1\n      /* BINARY */\n      ); // add the buffer to the param writer\n\n      paramWriter.addInt32(mappedVal.length);\n      paramWriter.add(mappedVal);\n    } else {\n      // add the param type (string) to the writer\n      writer.addInt16(0\n      /* STRING */\n      );\n      paramWriter.addInt32(Buffer.byteLength(mappedVal));\n      paramWriter.addString(mappedVal);\n    }\n  }\n};\n\nvar bind = function bind() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // normalize config\n  var portal = config.portal || '';\n  var statement = config.statement || '';\n  var binary = config.binary || false;\n  var values = config.values || emptyArray;\n  var len = values.length;\n  writer.addCString(portal).addCString(statement);\n  writer.addInt16(len);\n  writeValues(values, config.valueMapper);\n  writer.addInt16(len);\n  writer.add(paramWriter.flush()); // format code\n\n  writer.addInt16(binary ? 1\n  /* BINARY */\n  : 0\n  /* STRING */\n  );\n  return writer.flush(66\n  /* bind */\n  );\n};\n\nvar emptyExecute = Buffer.from([69\n/* execute */\n, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00]);\n\nvar execute = function execute(config) {\n  // this is the happy path for most queries\n  if (!config || !config.portal && !config.rows) {\n    return emptyExecute;\n  }\n\n  var portal = config.portal || '';\n  var rows = config.rows || 0;\n  var portalLength = Buffer.byteLength(portal);\n  var len = 4 + portalLength + 1 + 4; // one extra bit for code\n\n  var buff = Buffer.allocUnsafe(1 + len);\n  buff[0] = 69\n  /* execute */\n  ;\n  buff.writeInt32BE(len, 1);\n  buff.write(portal, 5, 'utf-8');\n  buff[portalLength + 5] = 0; // null terminate portal cString\n\n  buff.writeUInt32BE(rows, buff.length - 4);\n  return buff;\n};\n\nvar cancel = function cancel(processID, secretKey) {\n  var buffer = Buffer.allocUnsafe(16);\n  buffer.writeInt32BE(16, 0);\n  buffer.writeInt16BE(1234, 4);\n  buffer.writeInt16BE(5678, 6);\n  buffer.writeInt32BE(processID, 8);\n  buffer.writeInt32BE(secretKey, 12);\n  return buffer;\n};\n\nvar cstringMessage = function cstringMessage(code, string) {\n  var stringLen = Buffer.byteLength(string);\n  var len = 4 + stringLen + 1; // one extra bit for code\n\n  var buffer = Buffer.allocUnsafe(1 + len);\n  buffer[0] = code;\n  buffer.writeInt32BE(len, 1);\n  buffer.write(string, 5, 'utf-8');\n  buffer[len] = 0; // null terminate cString\n\n  return buffer;\n};\n\nvar emptyDescribePortal = writer.addCString('P').flush(68\n/* describe */\n);\nvar emptyDescribeStatement = writer.addCString('S').flush(68\n/* describe */\n);\n\nvar describe = function describe(msg) {\n  return msg.name ? cstringMessage(68\n  /* describe */\n  , \"\".concat(msg.type).concat(msg.name || '')) : msg.type === 'P' ? emptyDescribePortal : emptyDescribeStatement;\n};\n\nvar close = function close(msg) {\n  var text = \"\".concat(msg.type).concat(msg.name || '');\n  return cstringMessage(67\n  /* close */\n  , text);\n};\n\nvar copyData = function copyData(chunk) {\n  return writer.add(chunk).flush(100\n  /* copyFromChunk */\n  );\n};\n\nvar copyFail = function copyFail(message) {\n  return cstringMessage(102\n  /* copyFail */\n  , message);\n};\n\nvar codeOnlyBuffer = function codeOnlyBuffer(code) {\n  return Buffer.from([code, 0x00, 0x00, 0x00, 0x04]);\n};\n\nvar flushBuffer = codeOnlyBuffer(72\n/* flush */\n);\nvar syncBuffer = codeOnlyBuffer(83\n/* sync */\n);\nvar endBuffer = codeOnlyBuffer(88\n/* end */\n);\nvar copyDoneBuffer = codeOnlyBuffer(99\n/* copyDone */\n);\nvar serialize = {\n  startup: startup,\n  password: password,\n  requestSsl: requestSsl,\n  sendSASLInitialResponseMessage: sendSASLInitialResponseMessage,\n  sendSCRAMClientFinalMessage: sendSCRAMClientFinalMessage,\n  query: query,\n  parse: parse,\n  bind: bind,\n  execute: execute,\n  describe: describe,\n  close: close,\n  flush: function flush() {\n    return flushBuffer;\n  },\n  sync: function sync() {\n    return syncBuffer;\n  },\n  end: function end() {\n    return endBuffer;\n  },\n  copyData: copyData,\n  copyDone: function copyDone() {\n    return copyDoneBuffer;\n  },\n  copyFail: copyFail,\n  cancel: cancel\n};\nexports.serialize = serialize;","map":null,"metadata":{},"sourceType":"script"}