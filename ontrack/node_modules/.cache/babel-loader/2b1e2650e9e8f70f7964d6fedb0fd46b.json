{"ast":null,"code":"// Copyright 2011 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n'use strict';\n\nvar ipaddr = require('ipaddr.js'),\n    net = require('net'),\n    util = require('util'),\n    EventEmitter = require('events').EventEmitter,\n    PendingRequests = require('./pending'),\n    Packet = require('./packet'),\n    consts = require('native-dns-packet').consts,\n    utils = require('./utils'),\n    platform = require('./platform');\n\nvar A = consts.NAME_TO_QTYPE.A,\n    AAAA = consts.NAME_TO_QTYPE.AAAA,\n    MX = consts.NAME_TO_QTYPE.MX,\n    TXT = consts.NAME_TO_QTYPE.TXT,\n    NS = consts.NAME_TO_QTYPE.NS,\n    CNAME = consts.NAME_TO_QTYPE.CNAME,\n    SRV = consts.NAME_TO_QTYPE.SRV,\n    PTR = consts.NAME_TO_QTYPE.PTR;\n\nvar debug = function debug() {};\n\nif (process.env.NODE_DEBUG && process.env.NODE_DEBUG.match(/dns/)) {\n  debug = function debug() {\n    var args = Array.prototype.slice.call(arguments);\n    console.error.apply(this, ['client', Date.now().toString()].concat(args));\n  };\n}\n\nvar Request = exports.Request = function (opts) {\n  if (!(this instanceof Request)) return new Request(opts);\n  this.question = opts.question;\n  this.server = opts.server;\n  if (typeof this.server === 'string' || this.server instanceof String) this.server = {\n    address: this.server,\n    port: 53,\n    type: 'udp'\n  };\n  if (!this.server || !this.server.address || !net.isIP(this.server.address)) throw new Error('Server object must be supplied with at least address');\n  if (!this.server.type || ['udp', 'tcp'].indexOf(this.server.type) === -1) this.server.type = 'udp';\n  if (!this.server.port) this.server.port = 53;\n  this.timeout = opts.timeout || 4 * 1000;\n  this.try_edns = opts.try_edns || false;\n  this.fired = false;\n  this.id = undefined;\n\n  if (opts.cache || opts.cache === false) {\n    this.cache = opts.cache;\n  } else {\n    this.cache = platform.cache;\n  }\n\n  debug('request created', this.question);\n};\n\nutil.inherits(Request, EventEmitter);\n\nRequest.prototype.handle = function (err, answer, cached) {\n  if (!this.fired) {\n    debug('request handled', this.id, this.question);\n\n    if (!cached && this.cache && this.cache.store && answer) {\n      this.cache.store(answer);\n    }\n\n    this.emit('message', err, answer);\n    this.done();\n  }\n};\n\nRequest.prototype.done = function () {\n  debug('request finished', this.id, this.question);\n  this.fired = true;\n  clearTimeout(this.timer_);\n  PendingRequests.remove(this);\n  this.emit('end');\n  this.id = undefined;\n};\n\nRequest.prototype.handleTimeout = function () {\n  if (!this.fired) {\n    debug('request timedout', this.id, this.question);\n    this.emit('timeout');\n    this.done();\n  }\n};\n\nRequest.prototype.error = function (err) {\n  if (!this.fired) {\n    debug('request error', err, this.id, this.question);\n    this.emit('error', err);\n    this.done();\n  }\n};\n\nRequest.prototype.send = function () {\n  debug('request starting', this.question);\n  var self = this;\n\n  if (this.cache && this.cache.lookup) {\n    this.cache.lookup(this.question, function (results) {\n      var packet;\n\n      if (!results) {\n        self._send();\n      } else {\n        packet = new Packet();\n        packet.answer = results.slice();\n        self.handle(null, packet, true);\n      }\n    });\n  } else {\n    this._send();\n  }\n};\n\nRequest.prototype._send = function () {\n  debug('request not in cache', this.question);\n  var self = this;\n  this.timer_ = setTimeout(function () {\n    self.handleTimeout();\n  }, this.timeout);\n  PendingRequests.send(self);\n};\n\nRequest.prototype.cancel = function () {\n  debug('request cancelled', this.id, this.question);\n  this.emit('cancelled');\n  this.done();\n};\n\nvar _queue = [];\n\nvar sendQueued = function sendQueued() {\n  debug('platform ready sending queued requests');\n\n  _queue.forEach(function (request) {\n    request.start();\n  });\n\n  _queue = [];\n};\n\nplatform.on('ready', function () {\n  sendQueued();\n});\n\nif (platform.ready) {\n  sendQueued();\n}\n\nvar Resolve = function Resolve(opts, cb) {\n  if (!(this instanceof Resolve)) return new Resolve(opts, cb);\n  this.opts = util._extend({\n    retryOnTruncate: true\n  }, opts);\n  this._domain = opts.domain;\n  this._rrtype = opts.rrtype;\n\n  this._buildQuestion(this._domain);\n\n  this._started = false;\n  this._current_server = undefined;\n  this._server_list = [];\n\n  if (opts.remote) {\n    this._server_list.push({\n      address: opts.remote,\n      port: 53,\n      type: 'tcp'\n    });\n\n    this._server_list.push({\n      address: opts.remote,\n      port: 53,\n      type: 'udp'\n    });\n  }\n\n  this._request = undefined;\n  this._type = 'getHostByName';\n  this._cb = cb;\n\n  if (!platform.ready) {\n    _queue.push(this);\n  } else {\n    this.start();\n  }\n};\n\nutil.inherits(Resolve, EventEmitter);\n\nResolve.prototype.cancel = function () {\n  if (this._request) {\n    this._request.cancel();\n  }\n};\n\nResolve.prototype._buildQuestion = function (name) {\n  debug('building question', name);\n  this.question = {\n    type: this._rrtype,\n    class: consts.NAME_TO_QCLASS.IN,\n    name: name\n  };\n};\n\nexports.Resolve = Resolve;\n\nResolve.prototype._emit = function (err, answer) {\n  debug('resolve end', this._domain);\n  var self = this;\n  process.nextTick(function () {\n    if (err) {\n      err.syscall = self._type;\n    }\n\n    self._cb(err, answer);\n  });\n};\n\nResolve.prototype._fillServers = function () {\n  debug('resolve filling servers', this._domain);\n  var tries = 0,\n      s,\n      t,\n      u,\n      slist;\n  slist = platform.name_servers;\n\n  while (this._server_list.length < platform.attempts) {\n    s = slist[tries % slist.length];\n    u = {\n      address: s.address,\n      port: s.port,\n      type: 'udp'\n    };\n    t = {\n      address: s.address,\n      port: s.port,\n      type: 'tcp'\n    };\n\n    this._server_list.push(u);\n\n    this._server_list.push(t);\n\n    tries += 1;\n  }\n\n  this._server_list.reverse();\n};\n\nResolve.prototype._popServer = function () {\n  debug('resolve pop server', this._current_server, this._domain);\n\n  this._server_list.splice(0, 1, this._current_server);\n};\n\nResolve.prototype._preStart = function () {\n  if (!this._started) {\n    this._started = new Date().getTime();\n    this.try_edns = platform.edns;\n    if (!this._server_list.length) this._fillServers();\n  }\n};\n\nResolve.prototype._shouldContinue = function () {\n  debug('resolve should continue', this._server_list.length, this._domain);\n  return this._server_list.length;\n};\n\nResolve.prototype._nextQuestion = function () {\n  debug('resolve next question', this._domain);\n};\n\nResolve.prototype.start = function () {\n  if (!this._started) {\n    this._preStart();\n  }\n\n  if (this._server_list.length === 0) {\n    debug('resolve no more servers', this._domain);\n    this.handleTimeout();\n  } else {\n    this._current_server = this._server_list.pop();\n    debug('resolve start', this._current_server, this._domain);\n    this._request = Request({\n      question: this.question,\n      server: this._current_server,\n      timeout: platform.timeout,\n      try_edns: this.try_edns\n    });\n\n    this._request.on('timeout', this._handleTimeout.bind(this));\n\n    this._request.on('message', this._handle.bind(this));\n\n    this._request.on('error', this._handle.bind(this));\n\n    this._request.send();\n  }\n};\n\nvar NOERROR = consts.NAME_TO_RCODE.NOERROR,\n    SERVFAIL = consts.NAME_TO_RCODE.SERVFAIL,\n    NOTFOUND = consts.NAME_TO_RCODE.NOTFOUND,\n    FORMERR = consts.NAME_TO_RCODE.FORMERR;\n\nResolve.prototype._handle = function (err, answer) {\n  var rcode, errno;\n\n  if (answer) {\n    rcode = answer.header.rcode;\n  }\n\n  debug('resolve handle', rcode, this._domain);\n\n  switch (rcode) {\n    case NOERROR:\n      // answer trucated retry with tcp\n      //console.log(answer);\n      if (answer.header.tc && this.opts.retryOnTruncate && this._shouldContinue()) {\n        debug('truncated', this._domain, answer);\n        this.emit('truncated', err, answer); // remove udp servers\n\n        this._server_list = this._server_list.filter(function (server) {\n          return server.type === 'tcp';\n        });\n        answer = undefined;\n      }\n\n      break;\n\n    case SERVFAIL:\n      if (this._shouldContinue()) {\n        this._nextQuestion(); //this._popServer();\n\n      } else {\n        errno = consts.SERVFAIL;\n      }\n\n      answer = undefined;\n      break;\n\n    case NOTFOUND:\n      if (this._shouldContinue()) {\n        this._nextQuestion();\n      } else {\n        errno = consts.NOTFOUND;\n      }\n\n      answer = undefined;\n      break;\n\n    case FORMERR:\n      if (this.try_edns) {\n        this.try_edns = false; //this._popServer();\n      } else {\n        errno = consts.FORMERR;\n      }\n\n      answer = undefined;\n      break;\n\n    default:\n      if (!err) {\n        errno = consts.RCODE_TO_NAME[rcode];\n        answer = undefined;\n      } else {\n        errno = consts.NOTFOUND;\n      }\n\n      break;\n  }\n\n  if (errno || answer) {\n    if (errno) {\n      err = new Error(this._type + ' ' + errno);\n      err.errno = err.code = errno;\n    }\n\n    this._emit(err, answer);\n  } else {\n    this.start();\n  }\n};\n\nResolve.prototype._handleTimeout = function () {\n  var err;\n\n  if (this._server_list.length === 0) {\n    debug('resolve timeout no more servers', this._domain);\n    err = new Error(this._type + ' ' + consts.TIMEOUT);\n    err.errno = consts.TIMEOUT;\n\n    this._emit(err, undefined);\n  } else {\n    debug('resolve timeout continue', this._domain);\n    this.start();\n  }\n};\n\nvar resolve = function resolve(domain, rrtype, ip, callback) {\n  var res;\n\n  if (!callback) {\n    callback = ip;\n    ip = undefined;\n  }\n\n  if (!callback) {\n    callback = rrtype;\n    rrtype = undefined;\n  }\n\n  rrtype = consts.NAME_TO_QTYPE[rrtype || 'A'];\n\n  if (rrtype === PTR) {\n    return reverse(domain, callback);\n  }\n\n  var opts = {\n    domain: domain,\n    rrtype: rrtype,\n    remote: ip\n  };\n  res = new Resolve(opts);\n\n  res._cb = function (err, response) {\n    var ret = [],\n        i,\n        a;\n\n    if (err) {\n      callback(err, response);\n      return;\n    }\n\n    for (i = 0; i < response.answer.length; i++) {\n      a = response.answer[i];\n\n      if (a.type === rrtype) {\n        switch (rrtype) {\n          case A:\n          case AAAA:\n            ret.push(a.address);\n            break;\n\n          case consts.NAME_TO_QTYPE.MX:\n            ret.push({\n              priority: a.priority,\n              exchange: a.exchange\n            });\n            break;\n\n          case TXT:\n          case NS:\n          case CNAME:\n          case PTR:\n            ret.push(a.data);\n            break;\n\n          case SRV:\n            ret.push({\n              priority: a.priority,\n              weight: a.weight,\n              port: a.port,\n              name: a.target\n            });\n            break;\n\n          default:\n            ret.push(a);\n            break;\n        }\n      }\n    }\n\n    if (ret.length === 0) {\n      ret = undefined;\n    }\n\n    callback(err, ret);\n  };\n\n  return res;\n};\n\nexports.resolve = resolve;\n\nvar resolve4 = function resolve4(domain, callback) {\n  return resolve(domain, 'A', function (err, results) {\n    callback(err, results);\n  });\n};\n\nexports.resolve4 = resolve4;\n\nvar resolve6 = function resolve6(domain, callback) {\n  return resolve(domain, 'AAAA', function (err, results) {\n    callback(err, results);\n  });\n};\n\nexports.resolve6 = resolve6;\n\nvar resolveMx = function resolveMx(domain, callback) {\n  return resolve(domain, 'MX', function (err, results) {\n    callback(err, results);\n  });\n};\n\nexports.resolveMx = resolveMx;\n\nvar resolveTxt = function resolveTxt(domain, callback) {\n  return resolve(domain, 'TXT', function (err, results) {\n    callback(err, results);\n  });\n};\n\nexports.resolveTxt = resolveTxt;\n\nvar resolveSrv = function resolveSrv(domain, callback) {\n  return resolve(domain, 'SRV', function (err, results) {\n    callback(err, results);\n  });\n};\n\nexports.resolveSrv = resolveSrv;\n\nvar resolveNs = function resolveNs(domain, callback) {\n  return resolve(domain, 'NS', function (err, results) {\n    callback(err, results);\n  });\n};\n\nexports.resolveNs = resolveNs;\n\nvar resolveCname = function resolveCname(domain, callback) {\n  return resolve(domain, 'CNAME', function (err, results) {\n    callback(err, results);\n  });\n};\n\nexports.resolveCname = resolveCname;\n\nvar reverse = function reverse(ip, callback) {\n  var error, opts, res;\n\n  if (!net.isIP(ip)) {\n    error = new Error('getHostByAddr ENOTIMP');\n    error.errno = error.code = 'ENOTIMP';\n    throw error;\n  }\n\n  opts = {\n    domain: utils.reverseIP(ip),\n    rrtype: PTR\n  };\n  res = new Lookup(opts);\n\n  res._cb = function (err, response) {\n    var results = [];\n\n    if (response) {\n      response.answer.forEach(function (a) {\n        if (a.type === PTR) {\n          results.push(a.data);\n        }\n      });\n    }\n\n    if (results.length === 0) {\n      results = undefined;\n    }\n\n    callback(err, results);\n  };\n\n  return res;\n};\n\nexports.reverse = reverse;\n\nvar Lookup = function Lookup(opts) {\n  Resolve.call(this, opts);\n  this._type = 'getaddrinfo';\n};\n\nutil.inherits(Lookup, Resolve);\n\nLookup.prototype.start = function () {\n  var self = this;\n\n  if (!this._started) {\n    this._search_path = platform.search_path.slice(0);\n\n    this._preStart();\n  }\n\n  platform.hosts.lookup(this.question, function (results) {\n    var packet;\n\n    if (results && results.length) {\n      debug('Lookup in hosts', results);\n      packet = new Packet();\n      packet.answer = results.slice();\n\n      self._emit(null, packet);\n    } else {\n      debug('Lookup not in hosts');\n      Resolve.prototype.start.call(self);\n    }\n  });\n};\n\nLookup.prototype._shouldContinue = function () {\n  debug('Lookup should continue', this._server_list.length, this._search_path.length);\n  return this._server_list.length && this._search_path.length;\n};\n\nLookup.prototype._nextQuestion = function () {\n  debug('Lookup next question');\n\n  this._buildQuestion([this._domain, this._search_path.pop()].join('.'));\n};\n\nvar lookup = function lookup(domain, family, callback) {\n  var rrtype, revip, res;\n\n  if (!callback) {\n    callback = family;\n    family = undefined;\n  }\n\n  if (!family) {\n    family = 4;\n  }\n\n  revip = net.isIP(domain);\n\n  if (revip === 4 || revip === 6) {\n    process.nextTick(function () {\n      callback(null, domain, revip);\n    });\n    return {};\n  }\n\n  if (!domain) {\n    process.nextTick(function () {\n      callback(null, null, family);\n    });\n    return {};\n  }\n\n  rrtype = consts.FAMILY_TO_QTYPE[family];\n  var opts = {\n    domain: domain,\n    rrtype: rrtype\n  };\n  res = new Lookup(opts);\n\n  res._cb = function (err, response) {\n    var i, afamily, address, a, all;\n\n    if (err) {\n      callback(err, undefined, undefined);\n      return;\n    }\n\n    all = response.answer.concat(response.additional);\n\n    for (i = 0; i < all.length; i++) {\n      a = all[i];\n\n      if (a.type === A || a.type === AAAA) {\n        afamily = consts.QTYPE_TO_FAMILY[a.type];\n        address = a.address;\n        break;\n      }\n    }\n\n    callback(err, address, afamily);\n  };\n\n  return res;\n};\n\nexports.lookup = lookup;","map":null,"metadata":{},"sourceType":"script"}