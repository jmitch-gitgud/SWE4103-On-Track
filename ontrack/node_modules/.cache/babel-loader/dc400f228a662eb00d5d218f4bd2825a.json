{"ast":null,"code":"// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Parse DNS messages\nvar util = require('util');\n\nvar constants = require('./constants');\n\nmodule.exports = {\n  'id': id,\n  'qr': qr,\n  'aa': aa,\n  'tc': tc,\n  'rd': rd,\n  'ra': ra,\n  'ad': ad,\n  'cd': cd,\n  'rcode': rcode,\n  'opcode': opcode,\n  'record_count': record_count,\n  'record_name': record_name,\n  'record_class': record_class,\n  'record_ttl': record_ttl,\n  'record_type': record_type,\n  'record_data': record_data,\n  'uncompress': uncompress,\n  'sections': sections,\n  'mx': mx,\n  'srv': srv,\n  'soa': soa,\n  'txt': txt\n};\n\nfunction id(msg) {\n  return msg.readUInt16BE(0);\n}\n\nfunction qr(msg) {\n  return msg.readUInt8(2) >> 7;\n}\n\nfunction opcode(msg) {\n  return msg.readUInt8(2) >> 3 & 0x0f;\n}\n\nfunction aa(msg) {\n  return msg.readUInt8(2) >> 2 & 0x01;\n}\n\nfunction tc(msg) {\n  return msg.readUInt8(2) >> 1 & 0x01;\n}\n\nfunction rd(msg) {\n  return msg.readUInt8(2) & 0x01;\n}\n\nfunction ra(msg) {\n  return msg.readUInt8(3) >> 7;\n}\n\nfunction ad(msg) {\n  return msg.readUInt8(3) >> 5 & 0x01;\n}\n\nfunction cd(msg) {\n  return msg.readUInt8(3) >> 4 & 0x01;\n}\n\nfunction rcode(msg) {\n  return msg.readUInt8(3) & 0x0f;\n}\n\nfunction record_count(msg, name) {\n  if (name == 'question') return msg.readUInt16BE(4);else if (name == 'answer') return msg.readUInt16BE(6);else if (name == 'authority') return msg.readUInt16BE(8);else if (name == 'additional') return msg.readUInt16BE(10);else throw new Error('Unknown section name: ' + name);\n}\n\nfunction record_name(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.name;\n}\n\nfunction record_class(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.class;\n}\n\nfunction record_type(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.type;\n}\n\nfunction record_ttl(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.ttl;\n}\n\nfunction record_data(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.data;\n}\n\nfunction record_class(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.class;\n}\n\nfunction record(msg, section_name, offset) {\n  if (typeof offset != 'number' || isNaN(offset) || offset < 0) throw new Error('Offset must be a natural number'); // Support msg being a previously-parsed sections object.\n\n  var sects = Buffer.isBuffer(msg) ? sections(msg) : msg;\n  var records = sects[section_name];\n  if (!records) throw new Error('No such section: \"' + section_name + '\"');\n  var rec = records[offset];\n  if (!rec) throw new Error('Bad offset for section \"' + section_name + '\": ' + offset);\n  return rec;\n}\n\nfunction sections(msg) {\n  // Count the times this message has been parsed, for debugging and testing purposes.\n  if ('__parsed' in msg) msg.__parsed += 1;\n  var position = 12 // First byte of the first section\n  ,\n      result = {\n    'question': [],\n    'answer': [],\n    'authority': [],\n    'additional': []\n  },\n      need = {\n    'question': record_count(msg, 'question'),\n    'answer': record_count(msg, 'answer'),\n    'authority': record_count(msg, 'authority'),\n    'additional': record_count(msg, 'additional')\n  };\n  var states = ['question', 'answer', 'authority', 'additional', 'done'],\n      state = states.shift();\n\n  while (true) {\n    if (state == 'done') return result;else if (result[state].length == need[state]) state = states.shift();else if (!state) throw new Error('Unknown parsing state at position ' + position + ': ' + JSON.stringify(state));else add_record();\n  }\n\n  function add_record() {\n    var record = {};\n    var data = domain_parts(msg, position);\n    record.name = data.parts.join('.');\n    position += data.length;\n    record.type = msg.readUInt16BE(position + 0);\n    record.class = msg.readUInt16BE(position + 2);\n    position += 4;\n\n    if (state != 'question') {\n      record.ttl = msg.readUInt32BE(position + 0);\n      var rdata_len = msg.readUInt16BE(position + 4);\n      position += 6;\n      record.data = msg.slice(position, position + rdata_len);\n      position += rdata_len;\n\n      if (constants.type(record.type) === 'OPT') {\n        // EDNS\n        if (record.name !== '') throw new Error('EDNS record option for non-root domain: ' + record.name);\n        record.udp_size = record.class;\n        delete record.class;\n        record.extended_rcode = record.ttl >> 24;\n        record.edns_version = record.ttl >> 16 & 0xff;\n        record.zero = record.ttl >> 8;\n        delete record.ttl;\n        record.data = Array.prototype.slice.call(record.data);\n      }\n    }\n\n    result[state] = result[state] || [];\n    result[state].push(record);\n  }\n}\n\nfunction mx(msg, data) {\n  return [data.readUInt16BE(0), uncompress(msg, data.slice(2))];\n}\n\nfunction srv(msg, data) {\n  return {\n    'priority': data.readUInt16BE(0),\n    'weight': data.readUInt16BE(2),\n    'port': data.readUInt16BE(4),\n    'target': uncompress(msg, data.slice(6)) // Techncially compression is not allowed in RFC 2782.\n\n  };\n}\n\nfunction soa(msg, data) {\n  var result = domain_parts(msg, data),\n      offset = result.length,\n      mname = result.parts.join('.');\n  result = domain_parts(msg, data.slice(offset));\n  var rname = result.parts.join('.');\n  offset += result.length;\n  return {\n    'mname': mname,\n    'rname': rname //.replace(/\\./, '@')\n    ,\n    'serial': data.readUInt32BE(offset + 0),\n    'refresh': data.readUInt32BE(offset + 4),\n    'retry': data.readUInt32BE(offset + 8),\n    'expire': data.readUInt32BE(offset + 12),\n    'ttl': data.readUInt32BE(offset + 16)\n  };\n}\n\nfunction txt(msg, data) {\n  var parts = [];\n\n  while (data.length) {\n    var len = data.readUInt8(0);\n    parts.push(data.slice(1, 1 + len).toString('ascii'));\n    data = data.slice(1 + len);\n  }\n\n  return parts;\n}\n\nfunction uncompress(msg, offset) {\n  var data = domain_parts(msg, offset);\n  return data.parts.join('.');\n}\n\nfunction domain_parts(msg, offset) {\n  if (Buffer.isBuffer(offset)) {\n    var full_message = msg;\n    msg = offset;\n    offset = 0;\n  }\n\n  if (typeof offset != 'number' || isNaN(offset) || offset < 0 || offset > msg.length) throw new Error('Bad offset: ' + offset);\n  var parts = [],\n      real_length = 0,\n      jumped = false;\n  var i = 0;\n\n  while (true) {\n    if (++i >= 100) throw new Error('Too many iterations uncompressing name');\n    var byte = msg.readUInt8(offset),\n        flags = byte >> 6,\n        len = byte & 0x3f; // 0 - 63\n\n    offset += 1;\n    add_length(1);\n\n    if (flags === 0x03) {\n      offset = (len << 8) + msg.readUInt8(offset);\n      add_length(1);\n      jumped = true; // If processing so far has just been on some given fragment, begin using the full message now.\n\n      msg = full_message || msg;\n    } else if (len == 0) return {\n      'parts': parts,\n      'length': real_length\n    };else {\n      parts.push(msg.toString('ascii', offset, offset + len));\n      offset += len;\n      add_length(len);\n    }\n  }\n\n  function add_length(amount) {\n    if (!jumped) real_length += amount;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}