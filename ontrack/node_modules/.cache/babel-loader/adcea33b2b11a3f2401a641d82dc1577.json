{"ast":null,"code":"// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Encode DNS messages\nvar util = require('util');\n\nvar constants = require('./constants');\n\nmodule.exports = {\n  'State': State\n};\nvar SECTIONS = ['question', 'answer', 'authority', 'additional'];\n\nfunction State() {\n  var self = this;\n  self.header = new Buffer(12);\n  self.position = 0;\n  self.question = [];\n  self.answer = [];\n  self.authority = [];\n  self.additional = [];\n  self.domains = {}; // The compression lookup table\n}\n\nState.prototype.toBinary = function () {\n  var self = this;\n  var bufs = [self.header];\n  self.question.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  self.answer.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  self.authority.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  self.additional.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  return Buffer.concat(bufs);\n};\n\nState.prototype.message = function (msg) {\n  var self = this; // ID\n\n  self.header.writeUInt16BE(msg.id, 0); // QR, opcode, AA, TC, RD\n\n  var byte = 0;\n  byte |= msg.type == 'response' ? 0x80 : 0x00;\n  byte |= msg.authoritative ? 0x04 : 0x00;\n  byte |= msg.truncated ? 0x02 : 0x00;\n  byte |= msg.recursion_desired ? 0x01 : 0x00;\n  var opcode_names = ['query', 'iquery', 'status', null, 'notify', 'update'],\n      opcode = opcode_names.indexOf(msg.opcode);\n  if (opcode == -1 || typeof msg.opcode != 'string') throw new Error('Unknown opcode: ' + msg.opcode);else byte |= opcode << 3;\n  self.header.writeUInt8(byte, 2); // RA, Z, AD, CD, Rcode\n\n  byte = 0;\n  byte |= msg.recursion_available ? 0x80 : 0x00;\n  byte |= msg.authenticated ? 0x20 : 0x00;\n  byte |= msg.checking_disabled ? 0x10 : 0x00;\n  byte |= msg.responseCode & 0x0f;\n  self.header.writeUInt8(byte, 3);\n  self.position = 12; // the beginning of the sections\n\n  SECTIONS.forEach(function (section) {\n    var records = msg[section] || [];\n    records.forEach(function (rec) {\n      self.record(section, rec);\n    });\n  }); // Write the section counts.\n\n  self.header.writeUInt16BE(self.question.length, 4);\n  self.header.writeUInt16BE(self.answer.length, 6);\n  self.header.writeUInt16BE(self.authority.length, 8);\n  self.header.writeUInt16BE(self.additional.length, 10);\n};\n\nState.prototype.record = function (section_name, record) {\n  var self = this;\n  var body = [],\n      buf; // Write the record name.\n\n  buf = self.encode(record.name);\n  body.push(buf);\n  self.position += buf.length;\n  var type = constants.type_to_number(record.type),\n      clas = constants.class_to_number(record.class); // Write the type.\n\n  buf = new Buffer(2);\n  buf.writeUInt16BE(type, 0);\n  body.push(buf);\n  self.position += 2; // Write the class.\n\n  buf = new Buffer(2);\n  buf.writeUInt16BE(clas, 0);\n  body.push(buf);\n  self.position += 2;\n\n  if (section_name != 'question') {\n    // Write the TTL.\n    buf = new Buffer(4);\n    buf.writeUInt32BE(record.ttl || 0, 0);\n    body.push(buf);\n    self.position += 4; // Write the rdata. Update the position now (the rdata length value) in case self.encode() runs.\n\n    var match, rdata;\n\n    switch (record.class + ' ' + record.type) {\n      case 'IN A':\n        rdata = record.data || '';\n        match = rdata.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n        if (!match) throw new Error('Bad ' + record.type + ' record data: ' + JSON.stringify(record));\n        rdata = [+match[1], +match[2], +match[3], +match[4]];\n        break;\n\n      case 'IN AAAA':\n        // [hbouvier] More robust parsing of ipV6 address\n        rdata = ipv6_to_array(record.data || '::');\n        if (rdata.length !== 8) throw new Error('Bad ' + record.type + ' record data: ' + JSON.stringify(record));\n        rdata = rdata.map(pair_to_buf);\n        break;\n\n      case 'IN MX':\n        var host = record.data[1];\n        rdata = [buf16(record.data[0]), self.encode(host, 2 + 2) // Adjust for the rdata length + preference values.\n        ];\n        break;\n\n      case 'IN SOA':\n        var mname = self.encode(record.data.mname, 2) // Adust for rdata length\n        ,\n            rname = self.encode(record.data.rname, 2 + mname.length);\n        rdata = [mname, rname, buf32(record.data.serial), buf32(record.data.refresh), buf32(record.data.retry), buf32(record.data.expire), buf32(record.data.ttl)];\n        break;\n\n      case 'IN NS':\n      case 'IN PTR':\n      case 'IN CNAME':\n        rdata = self.encode(record.data, 2); // Adjust for the rdata length\n\n        break;\n\n      case 'IN TXT':\n        rdata = record.data.map(function (part) {\n          part = new Buffer(part);\n          return [part.length, part];\n        });\n        break;\n\n      case 'IN SRV':\n        rdata = [buf16(record.data.priority), buf16(record.data.weight), buf16(record.data.port), self.encode(record.data.target, 2 + 6, 'nocompress') // Offset for rdata length + priority, weight, and port.\n        ];\n        break;\n\n      case 'IN DS':\n        rdata = [buf16(record.data.key_tag), new Buffer([record.data.algorithm]), new Buffer([record.data.digest_type]), new Buffer(record.data.digest)];\n        break;\n\n      case 'NONE A':\n        // I think this is no data, from RFC 2136 S. 2.4.3.\n        rdata = [];\n        break;\n\n      default:\n        throw new Error('Unsupported record type: ' + JSON.stringify(record));\n    } // Write the rdata length. (The position was already updated.)\n\n\n    rdata = flat(rdata);\n    buf = new Buffer(2);\n    buf.writeUInt16BE(rdata.length, 0);\n    body.push(buf);\n    self.position += 2; // Write the rdata.\n\n    self.position += rdata.length;\n    if (rdata.length > 0) body.push(new Buffer(rdata));\n  }\n\n  self[section_name].push(Buffer.concat(body));\n};\n\nState.prototype.encode = function (full_domain, position_offset, option) {\n  var self = this; // [hbouvier] Added default value\n\n  var domain = full_domain || '';\n  domain = domain.replace(/\\.$/, ''); // Strip the trailing dot.\n\n  position = self.position + (position_offset || 0);\n  var body = [],\n      bytes;\n  var i = 0;\n  var max_iterations = 40; // Enough for 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa\n\n  while (++i < max_iterations) {\n    if (domain == '') {\n      // Encode the root domain and be done.\n      body.push(new Buffer([0]));\n      return Buffer.concat(body);\n    } else if (self.domains[domain] && option !== 'nocompress') {\n      // Encode a pointer and be done.\n      body.push(new Buffer([0xc0, self.domains[domain]]));\n      return Buffer.concat(body);\n    } else {\n      // Encode the next part of the domain, saving its position in the lookup table for later.\n      self.domains[domain] = position;\n      var parts = domain.split(/\\./),\n          car = parts[0];\n      domain = parts.slice(1).join('.'); // Write the first part of the domain, with a length prefix.\n      //var part = parts[0]\n\n      var buf = new Buffer(car.length + 1);\n      buf.write(car, 1, car.length, 'ascii');\n      buf.writeUInt8(car.length, 0);\n      body.push(buf);\n      position += buf.length; //bytes.unshift(bytes.length)\n    }\n  }\n\n  throw new Error('Too many iterations encoding domain: ' + full_domain);\n}; //\n// Utilities\n//\n\n\nfunction buf32(value) {\n  var buf = new Buffer(4);\n  buf.writeUInt32BE(value, 0);\n  return buf;\n}\n\nfunction buf16(value) {\n  var buf = new Buffer(2);\n  buf.writeUInt16BE(value, 0);\n  return buf;\n}\n\nfunction flat(data) {\n  return Buffer.isBuffer(data) ? Array.prototype.slice.call(data) : Array.isArray(data) ? data.reduce(flatten, []) : [data];\n}\n\nfunction flatten(state, element) {\n  return Buffer.isBuffer(element) || Array.isArray(element) ? state.concat(flat(element)) : state.concat([element]);\n}\n\nfunction pair_to_buf(pair) {\n  // [hbouvier]  It is possible that the \"pair\" has less than 4 digits, lets\n  //             make sure that it has.\n  var pairLength = pair.length;\n  if (pairLength < 4) pair = \"0000\".substring(pairLength) + pair; // Convert a string of two hex bytes, e.g. \"89ab\" to a buffer.\n\n  if (!pair.match(/^[0-9a-fA-F]{4}$/)) throw new Error('Bad ' + record.type + ' record data: ' + JSON.stringify(record));\n  return new Buffer(pair, 'hex');\n} // [hbouvier] More robust parsing of ipV6 address\n\n\nfunction ipv6_to_array(string) {\n  var fullAddress = ['0', '0', '0', '0', '0', '0', '0', '0']; // Remove the contiguous empty strings generated by '::' and keep ony one.\n\n  var numbers = string.split(/:/).reduce(function (previous, current) {\n    if (previous instanceof Array === false) previous = [previous];\n\n    if (!(current === '' && previous[previous.length - 1] === '')) {\n      previous.push(current);\n    }\n\n    return previous;\n  }); // Replace the single empty string, by the number of '0' that\n  // were \"missing\" (e.g. shortened address)\n\n  var merged = [].concat.apply([], numbers.map(function (num) {\n    return num === '' ? fullAddress.slice(numbers.length - 1) : num;\n  }));\n  return merged;\n}","map":null,"metadata":{},"sourceType":"script"}